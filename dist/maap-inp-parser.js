/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\n\nconst peggy_1 = __importDefault(__webpack_require__(/*! peggy */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/peg.js\"));\n\nconst maapInpParser_pegjs_1 = __importDefault(__webpack_require__(/*! ./maapInpParser.pegjs */ \"./src/maapInpParser.pegjs\"));\n\nexports[\"default\"] = peggy_1.default.generate(maapInpParser_pegjs_1.default, {\n  output: 'parser'\n});\n\n//# sourceURL=webpack://maap-input-parser/./src/index.ts?");

/***/ }),

/***/ "./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/asts.js":
/*!*******************************************************************************************************!*\
  !*** ./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/asts.js ***!
  \*******************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst visitor = __webpack_require__(/*! ./visitor */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/visitor.js\");\n\n// AST utilities.\nconst asts = {\n  findRule(ast, name) {\n    for (let i = 0; i < ast.rules.length; i++) {\n      if (ast.rules[i].name === name) {\n        return ast.rules[i];\n      }\n    }\n\n    return undefined;\n  },\n\n  indexOfRule(ast, name) {\n    for (let i = 0; i < ast.rules.length; i++) {\n      if (ast.rules[i].name === name) {\n        return i;\n      }\n    }\n\n    return -1;\n  },\n\n  alwaysConsumesOnSuccess(ast, node) {\n    function consumesTrue()  { return true;  }\n    function consumesFalse() { return false; }\n\n    const consumes = visitor.build({\n      choice(node) {\n        return node.alternatives.every(consumes);\n      },\n\n      sequence(node) {\n        return node.elements.some(consumes);\n      },\n\n      simple_and: consumesFalse,\n      simple_not: consumesFalse,\n      optional: consumesFalse,\n      zero_or_more: consumesFalse,\n      semantic_and: consumesFalse,\n      semantic_not: consumesFalse,\n\n      rule_ref(node) {\n        return consumes(asts.findRule(ast, node.name));\n      },\n\n      literal(node) {\n        return node.value !== \"\";\n      },\n\n      class: consumesTrue,\n      any: consumesTrue\n    });\n\n    return consumes(node);\n  }\n};\n\nmodule.exports = asts;\n\n\n//# sourceURL=webpack://maap-input-parser/./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/asts.js?");

/***/ }),

/***/ "./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/index.js":
/*!********************************************************************************************************!*\
  !*** ./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/index.js ***!
  \********************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst generateBytecode = __webpack_require__(/*! ./passes/generate-bytecode */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/generate-bytecode.js\");\nconst generateJS = __webpack_require__(/*! ./passes/generate-js */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/generate-js.js\");\nconst inferenceMatchResult = __webpack_require__(/*! ./passes/inference-match-result */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/inference-match-result.js\");\nconst removeProxyRules = __webpack_require__(/*! ./passes/remove-proxy-rules */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/remove-proxy-rules.js\");\nconst reportDuplicateLabels = __webpack_require__(/*! ./passes/report-duplicate-labels */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/report-duplicate-labels.js\");\nconst reportDuplicateRules = __webpack_require__(/*! ./passes/report-duplicate-rules */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/report-duplicate-rules.js\");\nconst reportInfiniteRecursion = __webpack_require__(/*! ./passes/report-infinite-recursion */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/report-infinite-recursion.js\");\nconst reportInfiniteRepetition = __webpack_require__(/*! ./passes/report-infinite-repetition */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/report-infinite-repetition.js\");\nconst reportUndefinedRules = __webpack_require__(/*! ./passes/report-undefined-rules */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/report-undefined-rules.js\");\nconst reportIncorrectPlucking = __webpack_require__(/*! ./passes/report-incorrect-plucking */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/report-incorrect-plucking.js\");\nconst visitor = __webpack_require__(/*! ./visitor */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/visitor.js\");\n\nfunction processOptions(options, defaults) {\n  const processedOptions = {};\n\n  Object.keys(options).forEach(name => {\n    processedOptions[name] = options[name];\n  });\n\n  Object.keys(defaults).forEach(name => {\n    if (!Object.prototype.hasOwnProperty.call(processedOptions, name)) {\n      processedOptions[name] = defaults[name];\n    }\n  });\n\n  return processedOptions;\n}\n\nconst compiler = {\n  // AST node visitor builder. Useful mainly for plugins which manipulate the\n  // AST.\n  visitor,\n\n  // Compiler passes.\n  //\n  // Each pass is a function that is passed the AST. It can perform checks on it\n  // or modify it as needed. If the pass encounters a semantic error, it throws\n  // |peg.GrammarError|.\n  passes: {\n    check: [\n      reportUndefinedRules,\n      reportDuplicateRules,\n      reportDuplicateLabels,\n      reportInfiniteRecursion,\n      reportInfiniteRepetition,\n      reportIncorrectPlucking\n    ],\n    transform: [\n      removeProxyRules,\n      inferenceMatchResult,\n    ],\n    generate: [\n      generateBytecode,\n      generateJS\n    ]\n  },\n\n  // Generates a parser from a specified grammar AST. Throws |peg.GrammarError|\n  // if the AST contains a semantic error. Note that not all errors are detected\n  // during the generation and some may protrude to the generated parser and\n  // cause its malfunction.\n  compile(ast, passes, options) {\n    options = options !== undefined ? options : {};\n\n    options = processOptions(options, {\n      allowedStartRules: [ast.rules[0].name],\n      cache: false,\n      dependencies: {},\n      exportVar: null,\n      format: \"bare\",\n      output: \"parser\",\n      trace: false\n    });\n\n    Object.keys(passes).forEach(stage => {\n      passes[stage].forEach(p => { p(ast, options); });\n    });\n\n    switch (options.output) {\n      case \"parser\":\n        return eval(ast.code);\n\n      case \"source\":\n        return ast.code;\n\n      default:\n        throw new Error(\"Invalid output format: \" + options.output + \".\");\n    }\n  }\n};\n\nmodule.exports = compiler;\n\n\n//# sourceURL=webpack://maap-input-parser/./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/index.js?");

/***/ }),

/***/ "./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/opcodes.js":
/*!**********************************************************************************************************!*\
  !*** ./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/opcodes.js ***!
  \**********************************************************************************************************/
/***/ ((module) => {

eval("\n\n// Bytecode instruction opcodes.\nconst opcodes = {\n  // Stack Manipulation\n\n  /** @deprecated Unused */\n  PUSH:              0,    // PUSH c\n  PUSH_EMPTY_STRING: 35,   // PUSH_EMPTY_STRING\n  PUSH_UNDEFINED:    1,    // PUSH_UNDEFINED\n  PUSH_NULL:         2,    // PUSH_NULL\n  PUSH_FAILED:       3,    // PUSH_FAILED\n  PUSH_EMPTY_ARRAY:  4,    // PUSH_EMPTY_ARRAY\n  PUSH_CURR_POS:     5,    // PUSH_CURR_POS\n  POP:               6,    // POP\n  POP_CURR_POS:      7,    // POP_CURR_POS\n  POP_N:             8,    // POP_N n\n  NIP:               9,    // NIP\n  APPEND:            10,   // APPEND\n  WRAP:              11,   // WRAP n\n  TEXT:              12,   // TEXT\n  PLUCK:             36,   // PLUCK n, k, p1, ..., pK\n\n  // Conditions and Loops\n\n  IF:                13,   // IF t, f\n  IF_ERROR:          14,   // IF_ERROR t, f\n  IF_NOT_ERROR:      15,   // IF_NOT_ERROR t, f\n  WHILE_NOT_ERROR:   16,   // WHILE_NOT_ERROR b\n\n  // Matching\n\n  MATCH_ANY:        17,    // MATCH_ANY a, f, ...\n  MATCH_STRING:     18,    // MATCH_STRING s, a, f, ...\n  MATCH_STRING_IC:  19,    // MATCH_STRING_IC s, a, f, ...\n  MATCH_CHAR_CLASS: 20,    // MATCH_CHAR_CLASS c, a, f, ...\n  /** @deprecated Replaced with `MATCH_CHAR_CLASS` */\n  MATCH_REGEXP:     20,    // MATCH_REGEXP r, a, f, ...\n  ACCEPT_N:         21,    // ACCEPT_N n\n  ACCEPT_STRING:    22,    // ACCEPT_STRING s\n  FAIL:             23,    // FAIL e\n\n  // Calls\n\n  LOAD_SAVED_POS:    24,   // LOAD_SAVED_POS p\n  UPDATE_SAVED_POS:  25,   // UPDATE_SAVED_POS\n  CALL:              26,   // CALL f, n, pc, p1, p2, ..., pN\n\n  // Rules\n\n  RULE:              27,   // RULE r\n\n  // Failure Reporting\n\n  SILENT_FAILS_ON:   28,   // SILENT_FAILS_ON\n  SILENT_FAILS_OFF:  29    // SILENT_FAILS_OFF\n\n  // Because the tests have hard-coded opcode numbers, don't renumber\n  // existing opcodes.  New opcodes that have been put in the correct\n  // sections above are repeated here in order to ensure we don't\n  // reuse them.\n  //\n  // 30-34 reserved for @mingun\n  // PUSH_EMPTY_STRING: 35\n  // PLUCK: 36\n};\n\nmodule.exports = opcodes;\n\n\n//# sourceURL=webpack://maap-input-parser/./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/opcodes.js?");

/***/ }),

/***/ "./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/generate-bytecode.js":
/*!***************************************************************************************************************************!*\
  !*** ./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/generate-bytecode.js ***!
  \***************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst asts = __webpack_require__(/*! ../asts */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/asts.js\");\nconst op = __webpack_require__(/*! ../opcodes */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/opcodes.js\");\nconst visitor = __webpack_require__(/*! ../visitor */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/visitor.js\");\nconst { ALWAYS_MATCH, SOMETIMES_MATCH, NEVER_MATCH } = __webpack_require__(/*! ./inference-match-result */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/inference-match-result.js\");\n\n// Generates bytecode.\n//\n// Instructions\n// ============\n//\n// Stack Manipulation\n// ------------------\n//\n//  [35] PUSH_EMPTY_STRING\n//\n//        stack.push(\"\");\n//\n//  [1] PUSH_UNDEFINED\n//\n//        stack.push(undefined);\n//\n//  [2] PUSH_NULL\n//\n//        stack.push(null);\n//\n//  [3] PUSH_FAILED\n//\n//        stack.push(FAILED);\n//\n//  [4] PUSH_EMPTY_ARRAY\n//\n//        stack.push([]);\n//\n//  [5] PUSH_CURR_POS\n//\n//        stack.push(currPos);\n//\n//  [6] POP\n//\n//        stack.pop();\n//\n//  [7] POP_CURR_POS\n//\n//        currPos = stack.pop();\n//\n//  [8] POP_N n\n//\n//        stack.pop(n);\n//\n//  [9] NIP\n//\n//        value = stack.pop();\n//        stack.pop();\n//        stack.push(value);\n//\n// [10] APPEND\n//\n//        value = stack.pop();\n//        array = stack.pop();\n//        array.push(value);\n//        stack.push(array);\n//\n// [11] WRAP n\n//\n//        stack.push(stack.pop(n));\n//\n// [12] TEXT\n//\n//        stack.push(input.substring(stack.pop(), currPos));\n//\n// [36] PLUCK n, k, p1, ..., pK\n//\n//        value = [stack[p1], ..., stack[pK]]; // when k != 1\n//        -or-\n//        value = stack[p1];                   // when k == 1\n//\n//        stack.pop(n);\n//        stack.push(value);\n//\n// Conditions and Loops\n// --------------------\n//\n// [13] IF t, f\n//\n//        if (stack.top()) {\n//          interpret(ip + 3, ip + 3 + t);\n//        } else {\n//          interpret(ip + 3 + t, ip + 3 + t + f);\n//        }\n//\n// [14] IF_ERROR t, f\n//\n//        if (stack.top() === FAILED) {\n//          interpret(ip + 3, ip + 3 + t);\n//        } else {\n//          interpret(ip + 3 + t, ip + 3 + t + f);\n//        }\n//\n// [15] IF_NOT_ERROR t, f\n//\n//        if (stack.top() !== FAILED) {\n//          interpret(ip + 3, ip + 3 + t);\n//        } else {\n//          interpret(ip + 3 + t, ip + 3 + t + f);\n//        }\n//\n// [16] WHILE_NOT_ERROR b\n//\n//        while(stack.top() !== FAILED) {\n//          interpret(ip + 2, ip + 2 + b);\n//        }\n//\n// Matching\n// --------\n//\n// [17] MATCH_ANY a, f, ...\n//\n//        if (input.length > currPos) {\n//          interpret(ip + 3, ip + 3 + a);\n//        } else {\n//          interpret(ip + 3 + a, ip + 3 + a + f);\n//        }\n//\n// [18] MATCH_STRING s, a, f, ...\n//\n//        if (input.substr(currPos, literals[s].length) === literals[s]) {\n//          interpret(ip + 4, ip + 4 + a);\n//        } else {\n//          interpret(ip + 4 + a, ip + 4 + a + f);\n//        }\n//\n// [19] MATCH_STRING_IC s, a, f, ...\n//\n//        if (input.substr(currPos, literals[s].length).toLowerCase() === literals[s]) {\n//          interpret(ip + 4, ip + 4 + a);\n//        } else {\n//          interpret(ip + 4 + a, ip + 4 + a + f);\n//        }\n//\n// [20] MATCH_CHAR_CLASS c, a, f, ...\n//\n//        if (classes[c].test(input.charAt(currPos))) {\n//          interpret(ip + 4, ip + 4 + a);\n//        } else {\n//          interpret(ip + 4 + a, ip + 4 + a + f);\n//        }\n//\n// [21] ACCEPT_N n\n//\n//        stack.push(input.substring(currPos, n));\n//        currPos += n;\n//\n// [22] ACCEPT_STRING s\n//\n//        stack.push(literals[s]);\n//        currPos += literals[s].length;\n//\n// [23] FAIL e\n//\n//        stack.push(FAILED);\n//        fail(expectations[e]);\n//\n// Calls\n// -----\n//\n// [24] LOAD_SAVED_POS p\n//\n//        savedPos = stack[p];\n//\n// [25] UPDATE_SAVED_POS\n//\n//        savedPos = currPos;\n//\n// [26] CALL f, n, pc, p1, p2, ..., pN\n//\n//        value = functions[f](stack[p1], ..., stack[pN]);\n//        stack.pop(n);\n//        stack.push(value);\n//\n// Rules\n// -----\n//\n// [27] RULE r\n//\n//        stack.push(parseRule(r));\n//\n// Failure Reporting\n// -----------------\n//\n// [28] SILENT_FAILS_ON\n//\n//        silentFails++;\n//\n// [29] SILENT_FAILS_OFF\n//\n//        silentFails--;\n//\n// This pass can use the results of other previous passes, each of which can\n// change the AST (and, as consequence, the bytecode).\n//\n// In particular, if the pass |inferenceMatchResult| has been run before this pass,\n// then each AST node will contain a |match| property, which represents a possible\n// match result of the node:\n// - `<0` - node is never matched, for example, `!('a'*)` (negation of the always\n//          matched node). Generator can put |FAILED| to the stack immediately\n// - `=0` - sometimes node matched, sometimes not. This is the same behavior\n//          when |match| is missed\n// - `>0` - node is always matched, for example, `'a'*` (because result is an\n//          empty array, or an array with some elements). The generator does not\n//          need to add a check for |FAILED|, because it is impossible\n//\n// To handle the situation, when the |inferenceMatchResult| has not run (that\n// happens, for example, in tests), the |match| value extracted using the\n// `|0` trick, which performing cast of any value to an integer with value `0`\n// that is equivalent of an unknown match result and signals the generator that\n// runtime check for the |FAILED| is required. Trick is explained on the\n// Wikipedia page (https://en.wikipedia.org/wiki/Asm.js#Code_generation)\nfunction generateBytecode(ast) {\n  const literals = [];\n  const classes = [];\n  const expectations = [];\n  const functions = [];\n\n  function addLiteralConst(value) {\n    const index = literals.indexOf(value);\n\n    return index === -1 ? literals.push(value) - 1 : index;\n  }\n\n  function addClassConst(node) {\n    const cls = {\n      value: node.parts,\n      inverted: node.inverted,\n      ignoreCase: node.ignoreCase\n    };\n    const pattern = JSON.stringify(cls);\n    const index = classes.findIndex(c => JSON.stringify(c) === pattern);\n\n    return index === -1 ? classes.push(cls) - 1 : index;\n  }\n\n  function addExpectedConst(expected) {\n    const pattern = JSON.stringify(expected);\n    const index = expectations.findIndex(e => JSON.stringify(e) === pattern);\n\n    return index === -1 ? expectations.push(expected) - 1 : index;\n  }\n\n  function addFunctionConst(predicate, params, code) {\n    const func = { predicate, params, body: code };\n    const pattern = JSON.stringify(func);\n    const index = functions.findIndex(f => JSON.stringify(f) === pattern);\n\n    return index === -1 ? functions.push(func) - 1 : index;\n  }\n\n  function cloneEnv(env) {\n    const clone = {};\n\n    Object.keys(env).forEach(name => {\n      clone[name] = env[name];\n    });\n\n    return clone;\n  }\n\n  function buildSequence(first, ...args) {\n    return first.concat(...args);\n  }\n\n  function buildCondition(match, condCode, thenCode, elseCode) {\n    if (match === ALWAYS_MATCH) { return thenCode; }\n    if (match === NEVER_MATCH)  { return elseCode; }\n\n    return condCode.concat(\n      [thenCode.length, elseCode.length],\n      thenCode,\n      elseCode\n    );\n  }\n\n  function buildLoop(condCode, bodyCode) {\n    return condCode.concat([bodyCode.length], bodyCode);\n  }\n\n  function buildCall(functionIndex, delta, env, sp) {\n    const params = Object.keys(env).map(name => sp - env[name]);\n\n    return [op.CALL, functionIndex, delta, params.length].concat(params);\n  }\n\n  function buildSimplePredicate(expression, negative, context) {\n    const match = expression.match | 0;\n\n    return buildSequence(\n      [op.PUSH_CURR_POS],\n      [op.SILENT_FAILS_ON],\n      generate(expression, {\n        sp: context.sp + 1,\n        env: cloneEnv(context.env),\n        action: null\n      }),\n      [op.SILENT_FAILS_OFF],\n      buildCondition(\n        negative ? -match : match,\n        [negative ? op.IF_ERROR : op.IF_NOT_ERROR],\n        buildSequence(\n          [op.POP],\n          [negative ? op.POP : op.POP_CURR_POS],\n          [op.PUSH_UNDEFINED]\n        ),\n        buildSequence(\n          [op.POP],\n          [negative ? op.POP_CURR_POS : op.POP],\n          [op.PUSH_FAILED]\n        )\n      )\n    );\n  }\n\n  function buildSemanticPredicate(node, negative, context) {\n    const functionIndex = addFunctionConst(\n      true, Object.keys(context.env), node.code\n    );\n\n    return buildSequence(\n      [op.UPDATE_SAVED_POS],\n      buildCall(functionIndex, 0, context.env, context.sp),\n      buildCondition(\n        node.match | 0,\n        [op.IF],\n        buildSequence(\n          [op.POP],\n          negative ? [op.PUSH_FAILED] : [op.PUSH_UNDEFINED]\n        ),\n        buildSequence(\n          [op.POP],\n          negative ? [op.PUSH_UNDEFINED] : [op.PUSH_FAILED]\n        )\n      )\n    );\n  }\n\n  function buildAppendLoop(expressionCode) {\n    return buildLoop(\n      [op.WHILE_NOT_ERROR],\n      buildSequence([op.APPEND], expressionCode)\n    );\n  }\n\n  const generate = visitor.build({\n    grammar(node) {\n      node.rules.forEach(generate);\n\n      node.literals = literals;\n      node.classes = classes;\n      node.expectations = expectations;\n      node.functions = functions;\n    },\n\n    rule(node) {\n      node.bytecode = generate(node.expression, {\n        sp: -1,        // stack pointer\n        env: { },      // mapping of label names to stack positions\n        pluck: [],     // fields that have been picked\n        action: null   // action nodes pass themselves to children here\n      });\n    },\n\n    named(node, context) {\n      const match = node.match | 0;\n      // Expectation not required if node always fail\n      const nameIndex = match === NEVER_MATCH ? null : addExpectedConst(\n        { type: \"rule\", value: node.name }\n      );\n\n      // The code generated below is slightly suboptimal because |FAIL| pushes\n      // to the stack, so we need to stick a |POP| in front of it. We lack a\n      // dedicated instruction that would just report the failure and not touch\n      // the stack.\n      return buildSequence(\n        [op.SILENT_FAILS_ON],\n        generate(node.expression, context),\n        [op.SILENT_FAILS_OFF],\n        buildCondition(match, [op.IF_ERROR], [op.FAIL, nameIndex], [])\n      );\n    },\n\n    choice(node, context) {\n      function buildAlternativesCode(alternatives, context) {\n        const match = alternatives[0].match | 0;\n        const first = generate(alternatives[0], {\n          sp: context.sp,\n          env: cloneEnv(context.env),\n          action: null\n        });\n        // If an alternative always match, no need to generate code for the next\n        // alternatives. Because their will never tried to match, any side-effects\n        // from next alternatives is impossible so we can skip their generation\n        if (match === ALWAYS_MATCH) {\n          return first;\n        }\n\n        // Even if an alternative never match it can have side-effects from\n        // a semantic predicates or an actions, so we can not skip generation\n        // of the first alternative.\n        // We can do that when analysis for possible side-effects will be introduced\n        return buildSequence(\n          first,\n          alternatives.length > 1\n            ? buildCondition(\n                SOMETIMES_MATCH,\n                [op.IF_ERROR],\n                buildSequence(\n                  [op.POP],\n                  buildAlternativesCode(alternatives.slice(1), context)\n                ),\n                []\n              )\n            : []\n        );\n      }\n\n      return buildAlternativesCode(node.alternatives, context);\n    },\n\n    action(node, context) {\n      const env = cloneEnv(context.env);\n      const emitCall = node.expression.type !== \"sequence\"\n                    || node.expression.elements.length === 0;\n      const expressionCode = generate(node.expression, {\n        sp: context.sp + (emitCall ? 1 : 0),\n        env,\n        action: node\n      });\n      const match = node.expression.match | 0;\n      // Function only required if expression can match\n      const functionIndex = emitCall && match !== NEVER_MATCH\n        ? addFunctionConst(false, Object.keys(env), node.code)\n        : null;\n\n      return emitCall\n        ? buildSequence(\n            [op.PUSH_CURR_POS],\n            expressionCode,\n            buildCondition(\n              match,\n              [op.IF_NOT_ERROR],\n              buildSequence(\n                [op.LOAD_SAVED_POS, 1],\n                buildCall(functionIndex, 1, env, context.sp + 2)\n              ),\n              []\n            ),\n            [op.NIP]\n          )\n        : expressionCode;\n    },\n\n    sequence(node, context) {\n      function buildElementsCode(elements, context) {\n        if (elements.length > 0) {\n          const processedCount = node.elements.length - elements.length + 1;\n\n          return buildSequence(\n            generate(elements[0], {\n              sp: context.sp,\n              env: context.env,\n              pluck: context.pluck,\n              action: null\n            }),\n            buildCondition(\n              elements[0].match | 0,\n              [op.IF_NOT_ERROR],\n              buildElementsCode(elements.slice(1), {\n                sp: context.sp + 1,\n                env: context.env,\n                pluck: context.pluck,\n                action: context.action\n              }),\n              buildSequence(\n                processedCount > 1 ? [op.POP_N, processedCount] : [op.POP],\n                [op.POP_CURR_POS],\n                [op.PUSH_FAILED]\n              )\n            )\n          );\n        } else {\n          if (context.pluck.length > 0) {\n            return buildSequence(\n              [ op.PLUCK, node.elements.length + 1, context.pluck.length ],\n              context.pluck.map(eSP => context.sp - eSP)\n            );\n          }\n\n          if (context.action) {\n            const functionIndex = addFunctionConst(\n              false,\n              Object.keys(context.env),\n              context.action.code\n            );\n\n            return buildSequence(\n              [op.LOAD_SAVED_POS, node.elements.length],\n              buildCall(\n                functionIndex,\n                node.elements.length + 1,\n                context.env,\n                context.sp\n              )\n            );\n          } else {\n            return buildSequence([op.WRAP, node.elements.length], [op.NIP]);\n          }\n        }\n      }\n\n      return buildSequence(\n        [op.PUSH_CURR_POS],\n        buildElementsCode(node.elements, {\n          sp: context.sp + 1,\n          env: context.env,\n          pluck: [],\n          action: context.action\n        })\n      );\n    },\n\n    labeled(node, context) {\n      let env = context.env;\n      const label = node.label;\n      const sp = context.sp + 1;\n\n      if (label) {\n        env = cloneEnv(context.env);\n        context.env[node.label] = sp;\n      }\n\n      if (node.pick) {\n        context.pluck.push(sp);\n      }\n\n      return generate(node.expression, {\n        sp: context.sp,\n        env,\n        action: null\n      });\n    },\n\n    text(node, context) {\n      return buildSequence(\n        [op.PUSH_CURR_POS],\n        generate(node.expression, {\n          sp: context.sp + 1,\n          env: cloneEnv(context.env),\n          action: null\n        }),\n        buildCondition(\n          node.match | 0,\n          [op.IF_NOT_ERROR],\n          buildSequence([op.POP], [op.TEXT]),\n          [op.NIP]\n        )\n      );\n    },\n\n    simple_and(node, context) {\n      return buildSimplePredicate(node.expression, false, context);\n    },\n\n    simple_not(node, context) {\n      return buildSimplePredicate(node.expression, true, context);\n    },\n\n    optional(node, context) {\n      return buildSequence(\n        generate(node.expression, {\n          sp: context.sp,\n          env: cloneEnv(context.env),\n          action: null\n        }),\n        buildCondition(\n          // Check expression match, not the node match\n          // If expression always match, no need to replace FAILED to NULL,\n          // because FAILED will never appeared\n          -(node.expression.match | 0),\n          [op.IF_ERROR],\n          buildSequence([op.POP], [op.PUSH_NULL]),\n          []\n        )\n      );\n    },\n\n    zero_or_more(node, context) {\n      const expressionCode = generate(node.expression, {\n        sp: context.sp + 1,\n        env: cloneEnv(context.env),\n        action: null\n      });\n\n      return buildSequence(\n        [op.PUSH_EMPTY_ARRAY],\n        expressionCode,\n        buildAppendLoop(expressionCode),\n        [op.POP]\n      );\n    },\n\n    one_or_more(node, context) {\n      const expressionCode = generate(node.expression, {\n        sp: context.sp + 1,\n        env: cloneEnv(context.env),\n        action: null\n      });\n\n      return buildSequence(\n        [op.PUSH_EMPTY_ARRAY],\n        expressionCode,\n        buildCondition(\n          // Condition depends on the expression match, not the node match\n          node.expression.match | 0,\n          [op.IF_NOT_ERROR],\n          buildSequence(buildAppendLoop(expressionCode), [op.POP]),\n          buildSequence([op.POP], [op.POP], [op.PUSH_FAILED])\n        )\n      );\n    },\n\n    group(node, context) {\n      return generate(node.expression, {\n        sp: context.sp,\n        env: cloneEnv(context.env),\n        action: null\n      });\n    },\n\n    semantic_and(node, context) {\n      return buildSemanticPredicate(node, false, context);\n    },\n\n    semantic_not(node, context) {\n      return buildSemanticPredicate(node, true, context);\n    },\n\n    rule_ref(node) {\n      return [op.RULE, asts.indexOfRule(ast, node.name)];\n    },\n\n    literal(node) {\n      if (node.value.length > 0) {\n        const match = node.match | 0;\n        // String only required if condition is generated or string is\n        // case-sensitive and node always match\n        const needConst = match === SOMETIMES_MATCH\n                      || (match === ALWAYS_MATCH && !node.ignoreCase);\n        const stringIndex = needConst ? addLiteralConst(\n          node.ignoreCase ? node.value.toLowerCase() : node.value\n        ) : null;\n        // Expectation not required if node always match\n        const expectedIndex = match !== ALWAYS_MATCH ? addExpectedConst({\n          type: \"literal\",\n          value: node.value,\n          ignoreCase: node.ignoreCase\n        }) : null;\n\n        // For case-sensitive strings the value must match the beginning of the\n        // remaining input exactly. As a result, we can use |ACCEPT_STRING| and\n        // save one |substr| call that would be needed if we used |ACCEPT_N|.\n        return buildCondition(\n          match,\n          node.ignoreCase\n            ? [op.MATCH_STRING_IC, stringIndex]\n            : [op.MATCH_STRING, stringIndex],\n          node.ignoreCase\n            ? [op.ACCEPT_N, node.value.length]\n            : [op.ACCEPT_STRING, stringIndex],\n          [op.FAIL, expectedIndex]\n        );\n      }\n\n      return [op.PUSH_EMPTY_STRING];\n    },\n\n    class(node) {\n      const match = node.match | 0;\n      // Character class constant only required if condition is generated\n      const classIndex = match === SOMETIMES_MATCH ? addClassConst(node) : null;\n      // Expectation not required if node always match\n      const expectedIndex = match !== ALWAYS_MATCH ? addExpectedConst({\n        type: \"class\",\n        value: node.parts,\n        inverted: node.inverted,\n        ignoreCase: node.ignoreCase\n      }) : null;\n\n      return buildCondition(\n        match,\n        [op.MATCH_CHAR_CLASS, classIndex],\n        [op.ACCEPT_N, 1],\n        [op.FAIL, expectedIndex]\n      );\n    },\n\n    any(node) {\n      const match = node.match | 0;\n      // Expectation not required if node always match\n      const expectedIndex = match !== ALWAYS_MATCH ? addExpectedConst({\n        type: \"any\"\n      }) : null;\n\n      return buildCondition(\n        match,\n        [op.MATCH_ANY],\n        [op.ACCEPT_N, 1],\n        [op.FAIL, expectedIndex]\n      );\n    }\n  });\n\n  generate(ast);\n}\n\nmodule.exports = generateBytecode;\n\n\n//# sourceURL=webpack://maap-input-parser/./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/generate-bytecode.js?");

/***/ }),

/***/ "./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/generate-js.js":
/*!*********************************************************************************************************************!*\
  !*** ./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/generate-js.js ***!
  \*********************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst asts = __webpack_require__(/*! ../asts */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/asts.js\");\nconst op = __webpack_require__(/*! ../opcodes */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/opcodes.js\");\nconst Stack = __webpack_require__(/*! ../stack */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/stack.js\");\nconst VERSION = __webpack_require__(/*! ../../version */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/version.js\");\n\nfunction hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }\n\nfunction stringEscape(s) {\n  // ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a string\n  // literal except for the closing quote character, backslash, carriage\n  // return, line separator, paragraph separator, and line feed. Any character\n  // may appear in the form of an escape sequence.\n  //\n  // For portability, we also escape all control and non-ASCII characters.\n  return s\n    .replace(/\\\\/g,   \"\\\\\\\\\")   // backslash\n    .replace(/\"/g,    \"\\\\\\\"\")   // closing double quote\n    .replace(/\\0/g,   \"\\\\0\")    // null\n    .replace(/\\x08/g, \"\\\\b\")    // backspace\n    .replace(/\\t/g,   \"\\\\t\")    // horizontal tab\n    .replace(/\\n/g,   \"\\\\n\")    // line feed\n    .replace(/\\v/g,   \"\\\\v\")    // vertical tab\n    .replace(/\\f/g,   \"\\\\f\")    // form feed\n    .replace(/\\r/g,   \"\\\\r\")    // carriage return\n    .replace(/[\\x00-\\x0F]/g,          ch => \"\\\\x0\" + hex(ch))\n    .replace(/[\\x10-\\x1F\\x7F-\\xFF]/g, ch => \"\\\\x\"  + hex(ch))\n    .replace(/[\\u0100-\\u0FFF]/g,      ch => \"\\\\u0\" + hex(ch))\n    .replace(/[\\u1000-\\uFFFF]/g,      ch => \"\\\\u\"  + hex(ch));\n}\n\nfunction regexpClassEscape(s) {\n  // Based on ECMA-262, 5th ed., 7.8.5 & 15.10.1.\n  //\n  // For portability, we also escape all control and non-ASCII characters.\n  return s\n    .replace(/\\\\/g,   \"\\\\\\\\\")   // backslash\n    .replace(/\\//g,   \"\\\\/\")    // closing slash\n    .replace(/]/g,    \"\\\\]\")    // closing bracket\n    .replace(/\\^/g,   \"\\\\^\")    // caret\n    .replace(/-/g,    \"\\\\-\")    // dash\n    .replace(/\\0/g,   \"\\\\0\")    // null\n    .replace(/\\x08/g, \"\\\\b\")    // backspace\n    .replace(/\\t/g,   \"\\\\t\")    // horizontal tab\n    .replace(/\\n/g,   \"\\\\n\")    // line feed\n    .replace(/\\v/g,   \"\\\\v\")    // vertical tab\n    .replace(/\\f/g,   \"\\\\f\")    // form feed\n    .replace(/\\r/g,   \"\\\\r\")    // carriage return\n    .replace(/[\\x00-\\x0F]/g,          ch => \"\\\\x0\" + hex(ch))\n    .replace(/[\\x10-\\x1F\\x7F-\\xFF]/g, ch => \"\\\\x\"  + hex(ch))\n    .replace(/[\\u0100-\\u0FFF]/g,      ch => \"\\\\u0\" + hex(ch))\n    .replace(/[\\u1000-\\uFFFF]/g,      ch => \"\\\\u\"  + hex(ch));\n}\n\n// Generates parser JavaScript code.\nfunction generateJS(ast, options) {\n  // These only indent non-empty lines to avoid trailing whitespace.\n  function indent2(code) { return code.replace(/^(.+)$/gm, \"  $1\"); }\n\n  function l(i) { return \"peg$c\" + i; } // |literals[i]| of the abstract machine\n  function r(i) { return \"peg$r\" + i; } // |classes[i]| of the abstract machine\n  function e(i) { return \"peg$e\" + i; } // |expectations[i]| of the abstract machine\n  function f(i) { return \"peg$f\" + i; } // |actions[i]| of the abstract machine\n\n  function generateTables() {\n    function buildLiteral(literal) {\n      return \"\\\"\" + stringEscape(literal) + \"\\\"\";\n    }\n\n    function buildRegexp(cls) {\n      return \"/^[\"\n            + (cls.inverted ? \"^\" : \"\")\n            + cls.value.map(part =>\n                Array.isArray(part)\n                  ? regexpClassEscape(part[0])\n                    + \"-\"\n                    + regexpClassEscape(part[1])\n                  : regexpClassEscape(part)\n              ).join(\"\")\n            + \"]/\" + (cls.ignoreCase ? \"i\" : \"\");\n    }\n\n    function buildExpectation(e) {\n      switch (e.type) {\n        case \"rule\": {\n          return \"peg$otherExpectation(\\\"\" + stringEscape(e.value) + \"\\\")\";\n        }\n        case \"literal\": {\n          return \"peg$literalExpectation(\\\"\"\n                  + stringEscape(e.value)\n                  + \"\\\", \"\n                  + e.ignoreCase\n                  + \")\";\n        }\n        case \"class\": {\n          const parts = e.value.map(part =>\n            Array.isArray(part)\n              ? \"[\\\"\" + stringEscape(part[0]) + \"\\\", \\\"\" + stringEscape(part[1]) + \"\\\"]\"\n              : \"\\\"\"  + stringEscape(part) + \"\\\"\"\n          ).join(\", \");\n\n          return \"peg$classExpectation([\"\n                  + parts + \"], \"\n                  + e.inverted + \", \"\n                  + e.ignoreCase\n                  + \")\";\n        }\n        case \"any\": return \"peg$anyExpectation()\";\n        default: throw new Error(\"Unknown expectation type (\" + JSON.stringify(e) + \")\");\n      }\n    }\n\n    function buildFunc(a) {\n      return \"function(\" + a.params.join(\", \") + \") {\"\n             + a.body\n             + \"}\";\n    }\n\n    return ast.literals.map(\n      (c, i) => \"var \" + l(i) + \" = \" + buildLiteral(c) + \";\"\n    ).concat(\"\", ast.classes.map(\n      (c, i) => \"var \" + r(i) + \" = \" + buildRegexp(c) + \";\"\n    )).concat(\"\", ast.expectations.map(\n      (c, i) => \"var \" + e(i) + \" = \" + buildExpectation(c) + \";\"\n    )).concat(\"\", ast.functions.map(\n      (c, i) => \"var \" + f(i) + \" = \" + buildFunc(c) + \";\"\n    )).join(\"\\n\");\n  }\n\n  function generateRuleHeader(ruleNameCode, ruleIndexCode) {\n    const parts = [];\n\n    parts.push(\"\");\n\n    if (options.trace) {\n      parts.push([\n        \"peg$tracer.trace({\",\n        \"  type: \\\"rule.enter\\\",\",\n        \"  rule: \" + ruleNameCode + \",\",\n        \"  location: peg$computeLocation(startPos, startPos)\",\n        \"});\",\n        \"\"\n      ].join(\"\\n\"));\n    }\n\n    if (options.cache) {\n      parts.push([\n        \"var key = peg$currPos * \" + ast.rules.length + \" + \" + ruleIndexCode + \";\",\n        \"var cached = peg$resultsCache[key];\",\n        \"\",\n        \"if (cached) {\",\n        \"  peg$currPos = cached.nextPos;\",\n        \"\"\n      ].join(\"\\n\"));\n\n      if (options.trace) {\n        parts.push([\n          \"if (cached.result !== peg$FAILED) {\",\n          \"  peg$tracer.trace({\",\n          \"    type: \\\"rule.match\\\",\",\n          \"    rule: \" + ruleNameCode + \",\",\n          \"    result: cached.result,\",\n          \"    location: peg$computeLocation(startPos, peg$currPos)\",\n          \"  });\",\n          \"} else {\",\n          \"  peg$tracer.trace({\",\n          \"    type: \\\"rule.fail\\\",\",\n          \"    rule: \" + ruleNameCode + \",\",\n          \"    location: peg$computeLocation(startPos, startPos)\",\n          \"  });\",\n          \"}\",\n          \"\"\n        ].join(\"\\n\"));\n      }\n\n      parts.push([\n        \"  return cached.result;\",\n        \"}\",\n        \"\"\n      ].join(\"\\n\"));\n    }\n\n    return parts.join(\"\\n\");\n  }\n\n  function generateRuleFooter(ruleNameCode, resultCode) {\n    const parts = [];\n\n    if (options.cache) {\n      parts.push([\n        \"\",\n        \"peg$resultsCache[key] = { nextPos: peg$currPos, result: \" + resultCode + \" };\"\n      ].join(\"\\n\"));\n    }\n\n    if (options.trace) {\n      parts.push([\n        \"\",\n        \"if (\" + resultCode + \" !== peg$FAILED) {\",\n        \"  peg$tracer.trace({\",\n        \"    type: \\\"rule.match\\\",\",\n        \"    rule: \" + ruleNameCode + \",\",\n        \"    result: \" + resultCode + \",\",\n        \"    location: peg$computeLocation(startPos, peg$currPos)\",\n        \"  });\",\n        \"} else {\",\n        \"  peg$tracer.trace({\",\n        \"    type: \\\"rule.fail\\\",\",\n        \"    rule: \" + ruleNameCode + \",\",\n        \"    location: peg$computeLocation(startPos, startPos)\",\n        \"  });\",\n        \"}\"\n      ].join(\"\\n\"));\n    }\n\n    parts.push([\n      \"\",\n      \"return \" + resultCode + \";\"\n    ].join(\"\\n\"));\n\n    return parts.join(\"\\n\");\n  }\n\n  function generateRuleFunction(rule) {\n    const parts = [];\n    const stack = new Stack(rule.name, \"s\", \"var\");\n\n    function compile(bc) {\n      let ip = 0;\n      const end = bc.length;\n      const parts = [];\n      let value;\n\n      function compileCondition(cond, argCount) {\n        const baseLength = argCount + 3;\n        const thenLength = bc[ip + baseLength - 2];\n        const elseLength = bc[ip + baseLength - 1];\n        let thenCode, elseCode;\n\n        stack.checkedIf(ip,\n          () => {\n            ip += baseLength;\n            thenCode = compile(bc.slice(ip, ip + thenLength));\n            ip += thenLength;\n          },\n          elseLength > 0 ? () => {\n            elseCode = compile(bc.slice(ip, ip + elseLength));\n            ip += elseLength;\n          } : null\n        );\n\n        parts.push(\"if (\" + cond + \") {\");\n        parts.push(indent2(thenCode));\n        if (elseLength > 0) {\n          parts.push(\"} else {\");\n          parts.push(indent2(elseCode));\n        }\n        parts.push(\"}\");\n      }\n\n      function compileLoop(cond) {\n        const baseLength = 2;\n        const bodyLength = bc[ip + baseLength - 1];\n        let bodyCode;\n\n        stack.checkedLoop(ip, () => {\n          ip += baseLength;\n          bodyCode = compile(bc.slice(ip, ip + bodyLength));\n          ip += bodyLength;\n        });\n\n        parts.push(\"while (\" + cond + \") {\");\n        parts.push(indent2(bodyCode));\n        parts.push(\"}\");\n      }\n\n      function compileCall() {\n        const baseLength = 4;\n        const paramsLength = bc[ip + baseLength - 1];\n\n        const value = f(bc[ip + 1]) + \"(\"\n          + bc.slice(ip + baseLength, ip + baseLength + paramsLength).map(\n              p => stack.index(p)\n            ).join(\", \")\n          + \")\";\n        stack.pop(bc[ip + 2]);\n        parts.push(stack.push(value));\n        ip += baseLength + paramsLength;\n      }\n\n      while (ip < end) {\n        switch (bc[ip]) {\n          case op.PUSH_EMPTY_STRING:  // PUSH_EMPTY_STRING\n            parts.push(stack.push(\"''\"));\n            ip++;\n            break;\n\n          case op.PUSH_CURR_POS:      // PUSH_CURR_POS\n            parts.push(stack.push(\"peg$currPos\"));\n            ip++;\n            break;\n\n          case op.PUSH_UNDEFINED:     // PUSH_UNDEFINED\n            parts.push(stack.push(\"undefined\"));\n            ip++;\n            break;\n\n          case op.PUSH_NULL:          // PUSH_NULL\n            parts.push(stack.push(\"null\"));\n            ip++;\n            break;\n\n          case op.PUSH_FAILED:        // PUSH_FAILED\n            parts.push(stack.push(\"peg$FAILED\"));\n            ip++;\n            break;\n\n          case op.PUSH_EMPTY_ARRAY:   // PUSH_EMPTY_ARRAY\n            parts.push(stack.push(\"[]\"));\n            ip++;\n            break;\n\n          case op.POP:                // POP\n            stack.pop();\n            ip++;\n            break;\n\n          case op.POP_CURR_POS:       // POP_CURR_POS\n            parts.push(\"peg$currPos = \" + stack.pop() + \";\");\n            ip++;\n            break;\n\n          case op.POP_N:              // POP_N n\n            stack.pop(bc[ip + 1]);\n            ip += 2;\n            break;\n\n          case op.NIP:                // NIP\n            value = stack.pop();\n            stack.pop();\n            parts.push(stack.push(value));\n            ip++;\n            break;\n\n          case op.APPEND:             // APPEND\n            value = stack.pop();\n            parts.push(stack.top() + \".push(\" + value + \");\");\n            ip++;\n            break;\n\n          case op.WRAP:               // WRAP n\n            parts.push(\n              // @ts-expect-error  pop() returns array if argument is specified\n              stack.push(\"[\" + stack.pop(bc[ip + 1]).join(\", \") + \"]\")\n            );\n            ip += 2;\n            break;\n\n          case op.TEXT:               // TEXT\n            parts.push(\n              stack.push(\"input.substring(\" + stack.pop() + \", peg$currPos)\")\n            );\n            ip++;\n            break;\n\n          case op.PLUCK: {            // PLUCK n, k, p1, ..., pK\n              const baseLength = 3;\n              const paramsLength = bc[ip + baseLength - 1];\n              const n = baseLength + paramsLength;\n              value = bc.slice(ip + baseLength, ip + n);\n              value = paramsLength === 1\n                  ? stack.index(value[0])\n                  : `[ ${\n                      value.map(p => stack.index(p)).join(\", \")\n                  } ]`;\n              stack.pop(bc[ip + 1]);\n              parts.push(stack.push(value));\n              ip += n;\n              break;\n          }\n\n          case op.IF:                 // IF t, f\n            compileCondition(stack.top(), 0);\n            break;\n\n          case op.IF_ERROR:           // IF_ERROR t, f\n            compileCondition(stack.top() + \" === peg$FAILED\", 0);\n            break;\n\n          case op.IF_NOT_ERROR:       // IF_NOT_ERROR t, f\n            compileCondition(stack.top() + \" !== peg$FAILED\", 0);\n            break;\n\n          case op.WHILE_NOT_ERROR:    // WHILE_NOT_ERROR b\n            compileLoop(stack.top() + \" !== peg$FAILED\");\n            break;\n\n          case op.MATCH_ANY:          // MATCH_ANY a, f, ...\n            compileCondition(\"input.length > peg$currPos\", 0);\n            break;\n\n          case op.MATCH_STRING:       // MATCH_STRING s, a, f, ...\n            compileCondition(\n              ast.literals[bc[ip + 1]].length > 1\n                ? \"input.substr(peg$currPos, \"\n                    + ast.literals[bc[ip + 1]].length\n                    + \") === \"\n                    + l(bc[ip + 1])\n                : \"input.charCodeAt(peg$currPos) === \"\n                    + ast.literals[bc[ip + 1]].charCodeAt(0),\n              1\n            );\n            break;\n\n          case op.MATCH_STRING_IC:    // MATCH_STRING_IC s, a, f, ...\n            compileCondition(\n              \"input.substr(peg$currPos, \"\n                + ast.literals[bc[ip + 1]].length\n                + \").toLowerCase() === \"\n                + l(bc[ip + 1]),\n              1\n            );\n            break;\n\n          case op.MATCH_CHAR_CLASS:   // MATCH_CHAR_CLASS c, a, f, ...\n            compileCondition(\n              r(bc[ip + 1]) + \".test(input.charAt(peg$currPos))\",\n              1\n            );\n            break;\n\n          case op.ACCEPT_N:           // ACCEPT_N n\n            parts.push(stack.push(\n              bc[ip + 1] > 1\n                ? \"input.substr(peg$currPos, \" + bc[ip + 1] + \")\"\n                : \"input.charAt(peg$currPos)\"\n            ));\n            parts.push(\n              bc[ip + 1] > 1\n                ? \"peg$currPos += \" + bc[ip + 1] + \";\"\n                : \"peg$currPos++;\"\n            );\n            ip += 2;\n            break;\n\n          case op.ACCEPT_STRING:      // ACCEPT_STRING s\n            parts.push(stack.push(l(bc[ip + 1])));\n            parts.push(\n              ast.literals[bc[ip + 1]].length > 1\n                ? \"peg$currPos += \" + ast.literals[bc[ip + 1]].length + \";\"\n                : \"peg$currPos++;\"\n            );\n            ip += 2;\n            break;\n\n          case op.FAIL:               // FAIL e\n            parts.push(stack.push(\"peg$FAILED\"));\n            parts.push(\"if (peg$silentFails === 0) { peg$fail(\" + e(bc[ip + 1]) + \"); }\");\n            ip += 2;\n            break;\n\n          case op.LOAD_SAVED_POS:     // LOAD_SAVED_POS p\n            parts.push(\"peg$savedPos = \" + stack.index(bc[ip + 1]) + \";\");\n            ip += 2;\n            break;\n\n          case op.UPDATE_SAVED_POS:   // UPDATE_SAVED_POS\n            parts.push(\"peg$savedPos = peg$currPos;\");\n            ip++;\n            break;\n\n          case op.CALL:               // CALL f, n, pc, p1, p2, ..., pN\n            compileCall();\n            break;\n\n          case op.RULE:               // RULE r\n            parts.push(stack.push(\"peg$parse\" + ast.rules[bc[ip + 1]].name + \"()\"));\n            ip += 2;\n            break;\n\n          case op.SILENT_FAILS_ON:    // SILENT_FAILS_ON\n            parts.push(\"peg$silentFails++;\");\n            ip++;\n            break;\n\n          case op.SILENT_FAILS_OFF:   // SILENT_FAILS_OFF\n            parts.push(\"peg$silentFails--;\");\n            ip++;\n            break;\n\n          default:\n            throw new Error(\"Invalid opcode: \" + bc[ip] + \".\");\n        }\n      }\n\n      return parts.join(\"\\n\");\n    }\n\n    const code = compile(rule.bytecode);\n\n    parts.push(\"function peg$parse\" + rule.name + \"() {\");\n\n    if (options.trace) {\n      parts.push(\"  var startPos = peg$currPos;\");\n    }\n\n    parts.push(indent2(stack.defines()));\n\n    parts.push(indent2(generateRuleHeader(\n      \"\\\"\" + stringEscape(rule.name) + \"\\\"\",\n      asts.indexOfRule(ast, rule.name)\n    )));\n    parts.push(indent2(code));\n    parts.push(indent2(generateRuleFooter(\n      \"\\\"\" + stringEscape(rule.name) + \"\\\"\",\n      stack.result()\n    )));\n\n    parts.push(\"}\");\n\n    return parts.join(\"\\n\");\n  }\n\n  function generateToplevel() {\n    const parts = [];\n\n    if (ast.topLevelInitializer) {\n      parts.push(ast.topLevelInitializer.code);\n      parts.push(\"\");\n    }\n\n    parts.push([\n      \"function peg$subclass(child, parent) {\",\n      \"  function C() { this.constructor = child; }\",\n      \"  C.prototype = parent.prototype;\",\n      \"  child.prototype = new C();\",\n      \"}\",\n      \"\",\n      \"function peg$SyntaxError(message, expected, found, location) {\",\n      \"  var self = Error.call(this, message);\",\n      \"  if (Object.setPrototypeOf) {\",\n      \"    Object.setPrototypeOf(self, peg$SyntaxError.prototype);\",\n      \"  }\",\n      \"  self.expected = expected;\",\n      \"  self.found = found;\",\n      \"  self.location = location;\",\n      \"  self.name = \\\"SyntaxError\\\";\",\n      \"  return self;\",\n      \"}\",\n      \"\",\n      \"peg$subclass(peg$SyntaxError, Error);\",\n      \"\",\n      \"function peg$padEnd(str, targetLength, padString) {\",\n      \"  padString = padString || \\\" \\\";\",\n      \"  if (str.length > targetLength) { return str; }\",\n      \"  targetLength -= str.length;\",\n      \"  padString += padString.repeat(targetLength);\",\n      \"  return str + padString.slice(0, targetLength);\",\n      \"}\",\n      \"\",\n      \"peg$SyntaxError.prototype.format = function(sources) {\",\n      \"  var str = \\\"Error: \\\" + this.message;\",\n      \"  if (this.location) {\",\n      \"    var src = null;\",\n      \"    var k;\",\n      \"    for (k = 0; k < sources.length; k++) {\",\n      \"      if (sources[k].source === this.location.source) {\",\n      \"        src = sources[k].text.split(/\\\\r\\\\n|\\\\n|\\\\r/g);\",\n      \"        break;\",\n      \"      }\",\n      \"    }\",\n      \"    var s = this.location.start;\",\n      \"    var loc = this.location.source + \\\":\\\" + s.line + \\\":\\\" + s.column;\",\n      \"    if (src) {\",\n      \"      var e = this.location.end;\",\n      \"      var filler = peg$padEnd(\\\"\\\", s.line.toString().length);\",\n      \"      var line = src[s.line - 1];\",\n      \"      var last = s.line === e.line ? e.column : line.length + 1;\",\n      \"      str += \\\"\\\\n --> \\\" + loc + \\\"\\\\n\\\"\",\n      \"          + filler + \\\" |\\\\n\\\"\",\n      \"          + s.line + \\\" | \\\" + line + \\\"\\\\n\\\"\",\n      \"          + filler + \\\" | \\\" + peg$padEnd(\\\"\\\", s.column - 1)\",\n      \"          + peg$padEnd(\\\"\\\", last - s.column, \\\"^\\\");\",\n      \"    } else {\",\n      \"      str += \\\"\\\\n at \\\" + loc;\",\n      \"    }\",\n      \"  }\",\n      \"  return str;\",\n      \"};\",\n      \"\",\n      \"peg$SyntaxError.buildMessage = function(expected, found) {\",\n      \"  var DESCRIBE_EXPECTATION_FNS = {\",\n      \"    literal: function(expectation) {\",\n      \"      return \\\"\\\\\\\"\\\" + literalEscape(expectation.text) + \\\"\\\\\\\"\\\";\",\n      \"    },\",\n      \"\",\n      \"    class: function(expectation) {\",\n      \"      var escapedParts = expectation.parts.map(function(part) {\",\n      \"        return Array.isArray(part)\",\n      \"          ? classEscape(part[0]) + \\\"-\\\" + classEscape(part[1])\",\n      \"          : classEscape(part);\",\n      \"      });\",\n      \"\",\n      \"      return \\\"[\\\" + (expectation.inverted ? \\\"^\\\" : \\\"\\\") + escapedParts + \\\"]\\\";\",\n      \"    },\",\n      \"\",\n      \"    any: function() {\",\n      \"      return \\\"any character\\\";\",\n      \"    },\",\n      \"\",\n      \"    end: function() {\",\n      \"      return \\\"end of input\\\";\",\n      \"    },\",\n      \"\",\n      \"    other: function(expectation) {\",\n      \"      return expectation.description;\",\n      \"    }\",\n      \"  };\",\n      \"\",\n      \"  function hex(ch) {\",\n      \"    return ch.charCodeAt(0).toString(16).toUpperCase();\",\n      \"  }\",\n      \"\",\n      \"  function literalEscape(s) {\",\n      \"    return s\",\n      \"      .replace(/\\\\\\\\/g, \\\"\\\\\\\\\\\\\\\\\\\")\",   // backslash\n      \"      .replace(/\\\"/g,  \\\"\\\\\\\\\\\\\\\"\\\")\",    // closing double quote\n      \"      .replace(/\\\\0/g, \\\"\\\\\\\\0\\\")\",       // null\n      \"      .replace(/\\\\t/g, \\\"\\\\\\\\t\\\")\",       // horizontal tab\n      \"      .replace(/\\\\n/g, \\\"\\\\\\\\n\\\")\",       // line feed\n      \"      .replace(/\\\\r/g, \\\"\\\\\\\\r\\\")\",       // carriage return\n      \"      .replace(/[\\\\x00-\\\\x0F]/g,          function(ch) { return \\\"\\\\\\\\x0\\\" + hex(ch); })\",\n      \"      .replace(/[\\\\x10-\\\\x1F\\\\x7F-\\\\x9F]/g, function(ch) { return \\\"\\\\\\\\x\\\"  + hex(ch); });\",\n      \"  }\",\n      \"\",\n      \"  function classEscape(s) {\",\n      \"    return s\",\n      \"      .replace(/\\\\\\\\/g, \\\"\\\\\\\\\\\\\\\\\\\")\",   // backslash\n      \"      .replace(/\\\\]/g, \\\"\\\\\\\\]\\\")\",       // closing bracket\n      \"      .replace(/\\\\^/g, \\\"\\\\\\\\^\\\")\",       // caret\n      \"      .replace(/-/g,  \\\"\\\\\\\\-\\\")\",        // dash\n      \"      .replace(/\\\\0/g, \\\"\\\\\\\\0\\\")\",       // null\n      \"      .replace(/\\\\t/g, \\\"\\\\\\\\t\\\")\",       // horizontal tab\n      \"      .replace(/\\\\n/g, \\\"\\\\\\\\n\\\")\",       // line feed\n      \"      .replace(/\\\\r/g, \\\"\\\\\\\\r\\\")\",       // carriage return\n      \"      .replace(/[\\\\x00-\\\\x0F]/g,          function(ch) { return \\\"\\\\\\\\x0\\\" + hex(ch); })\",\n      \"      .replace(/[\\\\x10-\\\\x1F\\\\x7F-\\\\x9F]/g, function(ch) { return \\\"\\\\\\\\x\\\"  + hex(ch); });\",\n      \"  }\",\n      \"\",\n      \"  function describeExpectation(expectation) {\",\n      \"    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\",\n      \"  }\",\n      \"\",\n      \"  function describeExpected(expected) {\",\n      \"    var descriptions = expected.map(describeExpectation);\",\n      \"    var i, j;\",\n      \"\",\n      \"    descriptions.sort();\",\n      \"\",\n      \"    if (descriptions.length > 0) {\",\n      \"      for (i = 1, j = 1; i < descriptions.length; i++) {\",\n      \"        if (descriptions[i - 1] !== descriptions[i]) {\",\n      \"          descriptions[j] = descriptions[i];\",\n      \"          j++;\",\n      \"        }\",\n      \"      }\",\n      \"      descriptions.length = j;\",\n      \"    }\",\n      \"\",\n      \"    switch (descriptions.length) {\",\n      \"      case 1:\",\n      \"        return descriptions[0];\",\n      \"\",\n      \"      case 2:\",\n      \"        return descriptions[0] + \\\" or \\\" + descriptions[1];\",\n      \"\",\n      \"      default:\",\n      \"        return descriptions.slice(0, -1).join(\\\", \\\")\",\n      \"          + \\\", or \\\"\",\n      \"          + descriptions[descriptions.length - 1];\",\n      \"    }\",\n      \"  }\",\n      \"\",\n      \"  function describeFound(found) {\",\n      \"    return found ? \\\"\\\\\\\"\\\" + literalEscape(found) + \\\"\\\\\\\"\\\" : \\\"end of input\\\";\",\n      \"  }\",\n      \"\",\n      \"  return \\\"Expected \\\" + describeExpected(expected) + \\\" but \\\" + describeFound(found) + \\\" found.\\\";\",\n      \"};\",\n      \"\"\n    ].join(\"\\n\"));\n\n    if (options.trace) {\n      parts.push([\n        \"function peg$DefaultTracer() {\",\n        \"  this.indentLevel = 0;\",\n        \"}\",\n        \"\",\n        \"peg$DefaultTracer.prototype.trace = function(event) {\",\n        \"  var that = this;\",\n        \"\",\n        \"  function log(event) {\",\n        \"    function repeat(string, n) {\",\n        \"       var result = \\\"\\\", i;\",\n        \"\",\n        \"       for (i = 0; i < n; i++) {\",\n        \"         result += string;\",\n        \"       }\",\n        \"\",\n        \"       return result;\",\n        \"    }\",\n        \"\",\n        \"    function pad(string, length) {\",\n        \"      return string + repeat(\\\" \\\", length - string.length);\",\n        \"    }\",\n        \"\",\n        \"    if (typeof console === \\\"object\\\") {\",   // IE 8-10\n        \"      console.log(\",\n        \"        event.location.start.line + \\\":\\\" + event.location.start.column + \\\"-\\\"\",\n        \"          + event.location.end.line + \\\":\\\" + event.location.end.column + \\\" \\\"\",\n        \"          + pad(event.type, 10) + \\\" \\\"\",\n        \"          + repeat(\\\"  \\\", that.indentLevel) + event.rule\",\n        \"      );\",\n        \"    }\",\n        \"  }\",\n        \"\",\n        \"  switch (event.type) {\",\n        \"    case \\\"rule.enter\\\":\",\n        \"      log(event);\",\n        \"      this.indentLevel++;\",\n        \"      break;\",\n        \"\",\n        \"    case \\\"rule.match\\\":\",\n        \"      this.indentLevel--;\",\n        \"      log(event);\",\n        \"      break;\",\n        \"\",\n        \"    case \\\"rule.fail\\\":\",\n        \"      this.indentLevel--;\",\n        \"      log(event);\",\n        \"      break;\",\n        \"\",\n        \"    default:\",\n        \"      throw new Error(\\\"Invalid event type: \\\" + event.type + \\\".\\\");\",\n        \"  }\",\n        \"};\",\n        \"\"\n      ].join(\"\\n\"));\n    }\n\n      const startRuleFunctions = \"{ \"\n      + options.allowedStartRules.map(\n          r => r + \": peg$parse\" + r\n        ).join(\", \")\n      + \" }\";\n      const startRuleFunction = \"peg$parse\" + options.allowedStartRules[0];\n\n    parts.push([\n      \"function peg$parse(input, options) {\",\n      \"  options = options !== undefined ? options : {};\",\n      \"\",\n      \"  var peg$FAILED = {};\",\n      \"  var peg$source = options.grammarSource;\",\n      \"\",\n      \"  var peg$startRuleFunctions = \" + startRuleFunctions + \";\",\n      \"  var peg$startRuleFunction = \" + startRuleFunction + \";\",\n      \"\",\n      indent2(generateTables()),\n      \"\",\n      \"  var peg$currPos = 0;\",\n      \"  var peg$savedPos = 0;\",\n      \"  var peg$posDetailsCache = [{ line: 1, column: 1 }];\",\n      \"  var peg$maxFailPos = 0;\",\n      \"  var peg$maxFailExpected = [];\",\n      \"  var peg$silentFails = 0;\",   // 0 = report failures, > 0 = silence failures\n      \"\"\n    ].join(\"\\n\"));\n\n    if (options.cache) {\n      parts.push([\n        \"  var peg$resultsCache = {};\",\n        \"\"\n      ].join(\"\\n\"));\n    }\n\n    if (options.trace) {\n      parts.push([\n        \"  var peg$tracer = \\\"tracer\\\" in options ? options.tracer : new peg$DefaultTracer();\",\n        \"\"\n      ].join(\"\\n\"));\n    }\n\n    parts.push([\n      \"  var peg$result;\",\n      \"\",\n      \"  if (\\\"startRule\\\" in options) {\",\n      \"    if (!(options.startRule in peg$startRuleFunctions)) {\",\n      \"      throw new Error(\\\"Can't start parsing from rule \\\\\\\"\\\" + options.startRule + \\\"\\\\\\\".\\\");\",\n      \"    }\",\n      \"\",\n      \"    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\",\n      \"  }\",\n      \"\",\n      \"  function text() {\",\n      \"    return input.substring(peg$savedPos, peg$currPos);\",\n      \"  }\",\n      \"\",\n      \"  function offset() {\",\n      \"    return peg$savedPos;\",\n      \"  }\",\n      \"\",\n      \"  function range() {\",\n      \"    return {\",\n      \"      source: peg$source,\",\n      \"      start: peg$savedPos,\",\n      \"      end: peg$currPos\",\n      \"    };\",\n      \"  }\",\n      \"\",\n      \"  function location() {\",\n      \"    return peg$computeLocation(peg$savedPos, peg$currPos);\",\n      \"  }\",\n      \"\",\n      \"  function expected(description, location) {\",\n      \"    location = location !== undefined\",\n      \"      ? location\",\n      \"      : peg$computeLocation(peg$savedPos, peg$currPos);\",\n      \"\",\n      \"    throw peg$buildStructuredError(\",\n      \"      [peg$otherExpectation(description)],\",\n      \"      input.substring(peg$savedPos, peg$currPos),\",\n      \"      location\",\n      \"    );\",\n      \"  }\",\n      \"\",\n      \"  function error(message, location) {\",\n      \"    location = location !== undefined\",\n      \"      ? location\",\n      \"      : peg$computeLocation(peg$savedPos, peg$currPos);\",\n      \"\",\n      \"    throw peg$buildSimpleError(message, location);\",\n      \"  }\",\n      \"\",\n      \"  function peg$literalExpectation(text, ignoreCase) {\",\n      \"    return { type: \\\"literal\\\", text: text, ignoreCase: ignoreCase };\",\n      \"  }\",\n      \"\",\n      \"  function peg$classExpectation(parts, inverted, ignoreCase) {\",\n      \"    return { type: \\\"class\\\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\",\n      \"  }\",\n      \"\",\n      \"  function peg$anyExpectation() {\",\n      \"    return { type: \\\"any\\\" };\",\n      \"  }\",\n      \"\",\n      \"  function peg$endExpectation() {\",\n      \"    return { type: \\\"end\\\" };\",\n      \"  }\",\n      \"\",\n      \"  function peg$otherExpectation(description) {\",\n      \"    return { type: \\\"other\\\", description: description };\",\n      \"  }\",\n      \"\",\n      \"  function peg$computePosDetails(pos) {\",\n      \"    var details = peg$posDetailsCache[pos];\",\n      \"    var p;\",\n      \"\",\n      \"    if (details) {\",\n      \"      return details;\",\n      \"    } else {\",\n      \"      p = pos - 1;\",\n      \"      while (!peg$posDetailsCache[p]) {\",\n      \"        p--;\",\n      \"      }\",\n      \"\",\n      \"      details = peg$posDetailsCache[p];\",\n      \"      details = {\",\n      \"        line: details.line,\",\n      \"        column: details.column\",\n      \"      };\",\n      \"\",\n      \"      while (p < pos) {\",\n      \"        if (input.charCodeAt(p) === 10) {\",\n      \"          details.line++;\",\n      \"          details.column = 1;\",\n      \"        } else {\",\n      \"          details.column++;\",\n      \"        }\",\n      \"\",\n      \"        p++;\",\n      \"      }\",\n      \"\",\n      \"      peg$posDetailsCache[pos] = details;\",\n      \"\",\n      \"      return details;\",\n      \"    }\",\n      \"  }\",\n      \"\",\n      \"  function peg$computeLocation(startPos, endPos) {\",\n      \"    var startPosDetails = peg$computePosDetails(startPos);\",\n      \"    var endPosDetails = peg$computePosDetails(endPos);\",\n      \"\",\n      \"    return {\",\n      \"      source: peg$source,\",\n      \"      start: {\",\n      \"        offset: startPos,\",\n      \"        line: startPosDetails.line,\",\n      \"        column: startPosDetails.column\",\n      \"      },\",\n      \"      end: {\",\n      \"        offset: endPos,\",\n      \"        line: endPosDetails.line,\",\n      \"        column: endPosDetails.column\",\n      \"      }\",\n      \"    };\",\n      \"  }\",\n      \"\",\n      \"  function peg$fail(expected) {\",\n      \"    if (peg$currPos < peg$maxFailPos) { return; }\",\n      \"\",\n      \"    if (peg$currPos > peg$maxFailPos) {\",\n      \"      peg$maxFailPos = peg$currPos;\",\n      \"      peg$maxFailExpected = [];\",\n      \"    }\",\n      \"\",\n      \"    peg$maxFailExpected.push(expected);\",\n      \"  }\",\n      \"\",\n      \"  function peg$buildSimpleError(message, location) {\",\n      \"    return new peg$SyntaxError(message, null, null, location);\",\n      \"  }\",\n      \"\",\n      \"  function peg$buildStructuredError(expected, found, location) {\",\n      \"    return new peg$SyntaxError(\",\n      \"      peg$SyntaxError.buildMessage(expected, found),\",\n      \"      expected,\",\n      \"      found,\",\n      \"      location\",\n      \"    );\",\n      \"  }\",\n      \"\"\n    ].join(\"\\n\"));\n\n    ast.rules.forEach(rule => {\n      parts.push(indent2(generateRuleFunction(rule)));\n      parts.push(\"\");\n    });\n\n    if (ast.initializer) {\n      parts.push(indent2(ast.initializer.code));\n      parts.push(\"\");\n    }\n\n    parts.push([\n      \"  peg$result = peg$startRuleFunction();\",\n      \"\",\n      \"  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\",\n      \"    return peg$result;\",\n      \"  } else {\",\n      \"    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\",\n      \"      peg$fail(peg$endExpectation());\",\n      \"    }\",\n      \"\",\n      \"    throw peg$buildStructuredError(\",\n      \"      peg$maxFailExpected,\",\n      \"      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\",\n      \"      peg$maxFailPos < input.length\",\n      \"        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\",\n      \"        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\",\n      \"    );\",\n      \"  }\",\n      \"}\"\n    ].join(\"\\n\"));\n\n    return parts.join(\"\\n\");\n  }\n\n  function generateWrapper(toplevelCode) {\n    function generateGeneratedByComment() {\n      return [\n        `// Generated by Peggy ${VERSION}.`,\n        \"//\",\n        \"// https://peggyjs.org/\"\n      ].join(\"\\n\");\n    }\n\n    function generateParserObject() {\n      return options.trace\n        ? [\n          \"{\",\n          \"  SyntaxError: peg$SyntaxError,\",\n          \"  DefaultTracer: peg$DefaultTracer,\",\n          \"  parse: peg$parse\",\n          \"}\"\n        ].join(\"\\n\")\n        : [\n          \"{\",\n          \"  SyntaxError: peg$SyntaxError,\",\n          \"  parse: peg$parse\",\n          \"}\"\n        ].join(\"\\n\");\n    }\n\n    function generateParserExports() {\n      return options.trace\n        ? [\n          \"{\",\n          \"  peg$SyntaxError as SyntaxError,\",\n          \"  peg$DefaultTracer as DefaultTracer,\",\n          \"  peg$parse as parse\",\n          \"}\"\n        ].join(\"\\n\")\n        : [\n          \"{\",\n          \"  peg$SyntaxError as SyntaxError,\",\n          \"  peg$parse as parse\",\n          \"}\"\n        ].join(\"\\n\");\n    }\n\n    const generators = {\n      bare() {\n        return [\n          generateGeneratedByComment(),\n          \"(function() {\",\n          \"  \\\"use strict\\\";\",\n          \"\",\n          indent2(toplevelCode),\n          \"\",\n          indent2(\"return \" + generateParserObject() + \";\"),\n          \"})()\"\n        ].join(\"\\n\");\n      },\n\n      commonjs() {\n        const parts = [];\n        const dependencyVars = Object.keys(options.dependencies);\n\n        parts.push([\n          generateGeneratedByComment(),\n          \"\",\n          \"\\\"use strict\\\";\",\n          \"\"\n        ].join(\"\\n\"));\n\n        if (dependencyVars.length > 0) {\n          dependencyVars.forEach(variable => {\n            parts.push(\"var \" + variable\n              + \" = require(\\\"\"\n              + stringEscape(options.dependencies[variable])\n              + \"\\\");\"\n            );\n          });\n          parts.push(\"\");\n        }\n\n        parts.push([\n          toplevelCode,\n          \"\",\n          \"module.exports = \" + generateParserObject() + \";\",\n          \"\"\n        ].join(\"\\n\"));\n\n        return parts.join(\"\\n\");\n      },\n\n      es() {\n        const parts = [];\n        const dependencyVars = Object.keys(options.dependencies);\n\n        parts.push(\n          generateGeneratedByComment(),\n          \"\"\n        );\n\n        if (dependencyVars.length > 0) {\n          dependencyVars.forEach(variable => {\n            parts.push(\"import \" + variable\n              + \" from \\\"\"\n              + stringEscape(options.dependencies[variable])\n              + \"\\\";\"\n            );\n          });\n          parts.push(\"\");\n        }\n\n        parts.push(\n          toplevelCode,\n          \"\",\n          \"export \" + generateParserExports() + \";\",\n          \"\"\n        );\n\n        return parts.join(\"\\n\");\n      },\n\n      amd() {\n        const dependencyVars = Object.keys(options.dependencies);\n        const dependencyIds = dependencyVars.map(v => options.dependencies[v]);\n        const dependencies = \"[\"\n          + dependencyIds.map(\n              id => \"\\\"\" + stringEscape(id) + \"\\\"\"\n            ).join(\", \")\n          + \"]\";\n        const params = dependencyVars.join(\", \");\n\n        return [\n          generateGeneratedByComment(),\n          \"define(\" + dependencies + \", function(\" + params + \") {\",\n          \"  \\\"use strict\\\";\",\n          \"\",\n          indent2(toplevelCode),\n          \"\",\n          indent2(\"return \" + generateParserObject() + \";\"),\n          \"});\",\n          \"\"\n        ].join(\"\\n\");\n      },\n\n      globals() {\n        return [\n          generateGeneratedByComment(),\n          \"(function(root) {\",\n          \"  \\\"use strict\\\";\",\n          \"\",\n          indent2(toplevelCode),\n          \"\",\n          indent2(\"root.\" + options.exportVar + \" = \" + generateParserObject() + \";\"),\n          \"})(this);\",\n          \"\"\n        ].join(\"\\n\");\n      },\n\n      umd() {\n        const parts = [];\n        const dependencyVars = Object.keys(options.dependencies);\n        const dependencyIds = dependencyVars.map(v => options.dependencies[v]);\n        const dependencies = \"[\"\n          + dependencyIds.map(\n              id => \"\\\"\" + stringEscape(id) + \"\\\"\"\n            ).join(\", \")\n          + \"]\";\n        const requires = dependencyIds.map(\n          id => \"require(\\\"\" + stringEscape(id) + \"\\\")\"\n        ).join(\", \");\n        const params = dependencyVars.join(\", \");\n\n        parts.push([\n          generateGeneratedByComment(),\n          \"(function(root, factory) {\",\n          \"  if (typeof define === \\\"function\\\" && define.amd) {\",\n          \"    define(\" + dependencies + \", factory);\",\n          \"  } else if (typeof module === \\\"object\\\" && module.exports) {\",\n          \"    module.exports = factory(\" + requires + \");\"\n        ].join(\"\\n\"));\n\n        if (options.exportVar !== null) {\n          parts.push([\n            \"  } else {\",\n            \"    root.\" + options.exportVar + \" = factory();\"\n          ].join(\"\\n\"));\n        }\n\n        parts.push([\n          \"  }\",\n          \"})(this, function(\" + params + \") {\",\n          \"  \\\"use strict\\\";\",\n          \"\",\n          indent2(toplevelCode),\n          \"\",\n          indent2(\"return \" + generateParserObject() + \";\"),\n          \"});\",\n          \"\"\n        ].join(\"\\n\"));\n\n        return parts.join(\"\\n\");\n      }\n    };\n\n    return generators[options.format]();\n  }\n\n  ast.code = generateWrapper(generateToplevel());\n}\n\nmodule.exports = generateJS;\n\n\n//# sourceURL=webpack://maap-input-parser/./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/generate-js.js?");

/***/ }),

/***/ "./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/inference-match-result.js":
/*!********************************************************************************************************************************!*\
  !*** ./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/inference-match-result.js ***!
  \********************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst visitor      = __webpack_require__(/*! ../visitor */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/visitor.js\");\nconst asts         = __webpack_require__(/*! ../asts */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/asts.js\");\nconst GrammarError = __webpack_require__(/*! ../../grammar-error */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/grammar-error.js\");\n\nconst ALWAYS_MATCH = 1;\nconst SOMETIMES_MATCH = 0;\nconst NEVER_MATCH = -1;\n\n// Inference match result of the each node. Can be:\n// -1: negative result, matching of that node always fails\n//  0: neutral result, may be fail, may be match\n//  1: positive result, always match\nfunction inferenceMatchResult(ast) {\n  function sometimesMatch(node) { return (node.match = SOMETIMES_MATCH); }\n  function alwaysMatch(node) {\n    inference(node.expression);\n\n    return (node.match = ALWAYS_MATCH);\n  }\n\n  function inferenceExpression(node) {\n    return (node.match = inference(node.expression));\n  }\n  function inferenceElements(elements, forChoice) {\n    const length = elements.length;\n    let always = 0;\n    let never = 0;\n\n    for (let i = 0; i < length; ++i) {\n      const result = inference(elements[i]);\n\n      if (result === ALWAYS_MATCH) { ++always; }\n      if (result === NEVER_MATCH)  { ++never;  }\n    }\n\n    if (always === length) {\n      return ALWAYS_MATCH;\n    }\n    if (forChoice) {\n      return never === length ? NEVER_MATCH : SOMETIMES_MATCH;\n    }\n\n    return never > 0 ? NEVER_MATCH : SOMETIMES_MATCH;\n  }\n\n  const inference = visitor.build({\n    rule(node) {\n      let oldResult;\n      let count = 0;\n\n      // If property not yet calculated, do that\n      if (typeof node.match === \"undefined\") {\n        node.match = SOMETIMES_MATCH;\n        do {\n          oldResult = node.match;\n          node.match = inference(node.expression);\n          // 6 == 3! -- permutations count for all transitions from one match\n          // state to another.\n          // After 6 iterations the cycle with guarantee begins\n          // For example, an input of `start = [] start` will generate the\n          // sequence: 0 -> -1 -> -1 (then stop)\n          //\n          // A more complex grammar theoretically would generate the\n          // sequence: 0 -> 1 -> 0 -> -1 -> 0 -> 1 -> ... (then cycle)\n          // but there are no examples of such grammars yet (possible, they\n          // do not exist at all)\n\n          // istanbul ignore next  This is canary test, shouldn't trigger in real life\n          if (++count > 6) {\n            throw new GrammarError(\n              \"Infinity cycle detected when trying to evaluate node match result\",\n              node.location\n            );\n          }\n        } while (oldResult !== node.match);\n      }\n\n      return node.match;\n    },\n    named:        inferenceExpression,\n    choice(node) {\n      return (node.match = inferenceElements(node.alternatives, true));\n    },\n    action:       inferenceExpression,\n    sequence(node) {\n      return (node.match = inferenceElements(node.elements, false));\n    },\n    labeled:      inferenceExpression,\n    text:         inferenceExpression,\n    simple_and:   inferenceExpression,\n    simple_not(node) {\n      return (node.match = -inference(node.expression));\n    },\n    optional:     alwaysMatch,\n    zero_or_more: alwaysMatch,\n    one_or_more:  inferenceExpression,\n    group:        inferenceExpression,\n    semantic_and: sometimesMatch,\n    semantic_not: sometimesMatch,\n    rule_ref(node) {\n      const rule = asts.findRule(ast, node.name);\n\n      return (node.match = inference(rule));\n    },\n    literal(node) {\n      // Empty literal always match on any input\n      const match = node.value.length === 0 ? ALWAYS_MATCH : SOMETIMES_MATCH;\n\n      return (node.match = match);\n    },\n    class(node) {\n      // Empty character class never match on any input\n      const match = node.parts.length === 0 ? NEVER_MATCH : SOMETIMES_MATCH;\n\n      return (node.match = match);\n    },\n    // |any| not match on empty input\n    any:          sometimesMatch\n  });\n\n  inference(ast);\n}\n\ninferenceMatchResult.ALWAYS_MATCH    = ALWAYS_MATCH;\ninferenceMatchResult.SOMETIMES_MATCH = SOMETIMES_MATCH;\ninferenceMatchResult.NEVER_MATCH     = NEVER_MATCH;\n\nmodule.exports = inferenceMatchResult;\n\n\n//# sourceURL=webpack://maap-input-parser/./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/inference-match-result.js?");

/***/ }),

/***/ "./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/remove-proxy-rules.js":
/*!****************************************************************************************************************************!*\
  !*** ./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/remove-proxy-rules.js ***!
  \****************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst visitor = __webpack_require__(/*! ../visitor */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/visitor.js\");\n\n// Removes proxy rules -- that is, rules that only delegate to other rule.\nfunction removeProxyRules(ast, options) {\n  function isProxyRule(node) {\n    return node.type === \"rule\" && node.expression.type === \"rule_ref\";\n  }\n\n  function replaceRuleRefs(ast, from, to) {\n    const replace = visitor.build({\n      rule_ref(node) {\n        if (node.name === from) {\n          node.name = to;\n        }\n      }\n    });\n\n    replace(ast);\n  }\n\n  const indices = [];\n\n  ast.rules.forEach((rule, i) => {\n    if (isProxyRule(rule)) {\n      replaceRuleRefs(ast, rule.name, rule.expression.name);\n      if (options.allowedStartRules.indexOf(rule.name) === -1) {\n        indices.push(i);\n      }\n    }\n  });\n\n  indices.reverse();\n\n  indices.forEach(i => { ast.rules.splice(i, 1); });\n}\n\nmodule.exports = removeProxyRules;\n\n\n//# sourceURL=webpack://maap-input-parser/./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/remove-proxy-rules.js?");

/***/ }),

/***/ "./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/report-duplicate-labels.js":
/*!*********************************************************************************************************************************!*\
  !*** ./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/report-duplicate-labels.js ***!
  \*********************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst GrammarError = __webpack_require__(/*! ../../grammar-error */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/grammar-error.js\");\nconst visitor = __webpack_require__(/*! ../visitor */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/visitor.js\");\n\n// Checks that each label is defined only once within each scope.\nfunction reportDuplicateLabels(ast) {\n  function cloneEnv(env) {\n    const clone = {};\n\n    Object.keys(env).forEach(name => {\n      clone[name] = env[name];\n    });\n\n    return clone;\n  }\n\n  function checkExpressionWithClonedEnv(node, env) {\n    check(node.expression, cloneEnv(env));\n  }\n\n  const check = visitor.build({\n    rule(node) {\n      check(node.expression, { });\n    },\n\n    choice(node, env) {\n      node.alternatives.forEach(alternative => {\n        check(alternative, cloneEnv(env));\n      });\n    },\n\n    action: checkExpressionWithClonedEnv,\n\n    labeled(node, env) {\n      const label = node.label;\n      if (label && Object.prototype.hasOwnProperty.call(env, label)) {\n        throw new GrammarError(\n          `Label \"${node.label}\" is already defined`,\n          node.labelLocation,\n          [{\n            message: \"Original label location\",\n            location: env[label]\n          }]\n        );\n      }\n\n      check(node.expression, env);\n\n      env[node.label] = node.labelLocation;\n    },\n\n    text: checkExpressionWithClonedEnv,\n    simple_and: checkExpressionWithClonedEnv,\n    simple_not: checkExpressionWithClonedEnv,\n    optional: checkExpressionWithClonedEnv,\n    zero_or_more: checkExpressionWithClonedEnv,\n    one_or_more: checkExpressionWithClonedEnv,\n    group: checkExpressionWithClonedEnv\n  });\n\n  check(ast);\n}\n\nmodule.exports = reportDuplicateLabels;\n\n\n//# sourceURL=webpack://maap-input-parser/./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/report-duplicate-labels.js?");

/***/ }),

/***/ "./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/report-duplicate-rules.js":
/*!********************************************************************************************************************************!*\
  !*** ./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/report-duplicate-rules.js ***!
  \********************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst GrammarError = __webpack_require__(/*! ../../grammar-error */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/grammar-error.js\");\nconst visitor = __webpack_require__(/*! ../visitor */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/visitor.js\");\n\n// Checks that each rule is defined only once.\nfunction reportDuplicateRules(ast) {\n  const rules = {};\n\n  const check = visitor.build({\n    rule(node) {\n      if (Object.prototype.hasOwnProperty.call(rules, node.name)) {\n        throw new GrammarError(\n          `Rule \"${node.name}\" is already defined`,\n          node.nameLocation,\n          [{\n            message: \"Original rule location\",\n            location: rules[node.name]\n          }]\n        );\n      }\n\n      rules[node.name] = node.nameLocation;\n    }\n  });\n\n  check(ast);\n}\n\nmodule.exports = reportDuplicateRules;\n\n\n//# sourceURL=webpack://maap-input-parser/./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/report-duplicate-rules.js?");

/***/ }),

/***/ "./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/report-incorrect-plucking.js":
/*!***********************************************************************************************************************************!*\
  !*** ./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/report-incorrect-plucking.js ***!
  \***********************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst GrammarError = __webpack_require__(/*! ../../grammar-error */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/grammar-error.js\");\nconst visitor = __webpack_require__(/*! ../visitor */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/visitor.js\");\n\n//\n// Compiler pass to ensure the following are enforced:\n//\n//   - plucking can not be done with an action block\n//\nfunction reportIncorrectPlucking(ast) {\n  const check = visitor.build({\n    action(node) {\n      check(node.expression, node);\n    },\n\n    labeled(node, action) {\n      if (node.pick) {\n        if (action) {\n          throw new GrammarError(\n            \"\\\"@\\\" cannot be used with an action block\",\n            node.labelLocation,\n            [{\n              message: \"Action block location\",\n              location: action.codeLocation\n            }]\n          );\n        }\n      }\n\n      check(node.expression);\n    }\n  });\n\n  check(ast);\n}\n\nmodule.exports = reportIncorrectPlucking;\n\n\n//# sourceURL=webpack://maap-input-parser/./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/report-incorrect-plucking.js?");

/***/ }),

/***/ "./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/report-infinite-recursion.js":
/*!***********************************************************************************************************************************!*\
  !*** ./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/report-infinite-recursion.js ***!
  \***********************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst GrammarError = __webpack_require__(/*! ../../grammar-error */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/grammar-error.js\");\nconst asts = __webpack_require__(/*! ../asts */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/asts.js\");\nconst visitor = __webpack_require__(/*! ../visitor */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/visitor.js\");\n\n// Reports left recursion in the grammar, which prevents infinite recursion in\n// the generated parser.\n//\n// Both direct and indirect recursion is detected. The pass also correctly\n// reports cases like this:\n//\n//   start = \"a\"? start\n//\n// In general, if a rule reference can be reached without consuming any input,\n// it can lead to left recursion.\nfunction reportInfiniteRecursion(ast) {\n  // Array with rule names for error message\n  const visitedRules = [];\n  // Array with rule_refs for diagnostic\n  const backtraceRefs = [];\n\n  const check = visitor.build({\n    rule(node) {\n      visitedRules.push(node.name);\n      check(node.expression);\n      visitedRules.pop();\n    },\n\n    sequence(node) {\n      node.elements.every(element => {\n        check(element);\n\n        return !asts.alwaysConsumesOnSuccess(ast, element);\n      });\n    },\n\n    rule_ref(node) {\n      backtraceRefs.push(node);\n\n      const rule = asts.findRule(ast, node.name);\n\n      if (visitedRules.indexOf(node.name) !== -1) {\n        visitedRules.push(node.name);\n\n        throw new GrammarError(\n          \"Possible infinite loop when parsing (left recursion: \"\n            + visitedRules.join(\" -> \")\n            + \")\",\n          rule.nameLocation,\n          backtraceRefs.map((ref, i, a) => {\n            return {\n              message: i + 1 !== a.length\n                ? `Step ${i + 1}: call of the rule \"${ref.name}\" without input consumption`\n                : `Step ${i + 1}: call itself without input consumption - left recursion`,\n              location: ref.location\n            };\n          })\n        );\n      }\n\n      check(rule);\n      backtraceRefs.pop();\n    }\n  });\n\n  check(ast);\n}\n\nmodule.exports = reportInfiniteRecursion;\n\n\n//# sourceURL=webpack://maap-input-parser/./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/report-infinite-recursion.js?");

/***/ }),

/***/ "./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/report-infinite-repetition.js":
/*!************************************************************************************************************************************!*\
  !*** ./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/report-infinite-repetition.js ***!
  \************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst GrammarError = __webpack_require__(/*! ../../grammar-error */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/grammar-error.js\");\nconst asts = __webpack_require__(/*! ../asts */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/asts.js\");\nconst visitor = __webpack_require__(/*! ../visitor */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/visitor.js\");\n\n// Reports expressions that don't consume any input inside |*| or |+| in the\n// grammar, which prevents infinite loops in the generated parser.\nfunction reportInfiniteRepetition(ast) {\n  const check = visitor.build({\n    zero_or_more(node) {\n      if (!asts.alwaysConsumesOnSuccess(ast, node.expression)) {\n        throw new GrammarError(\n          \"Possible infinite loop when parsing (repetition used with an expression that may not consume any input)\",\n          node.location\n        );\n      }\n    },\n\n    one_or_more(node) {\n      if (!asts.alwaysConsumesOnSuccess(ast, node.expression)) {\n        throw new GrammarError(\n          \"Possible infinite loop when parsing (repetition used with an expression that may not consume any input)\",\n          node.location\n        );\n      }\n    }\n  });\n\n  check(ast);\n}\n\nmodule.exports = reportInfiniteRepetition;\n\n\n//# sourceURL=webpack://maap-input-parser/./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/report-infinite-repetition.js?");

/***/ }),

/***/ "./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/report-undefined-rules.js":
/*!********************************************************************************************************************************!*\
  !*** ./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/report-undefined-rules.js ***!
  \********************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst GrammarError = __webpack_require__(/*! ../../grammar-error */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/grammar-error.js\");\nconst asts = __webpack_require__(/*! ../asts */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/asts.js\");\nconst visitor = __webpack_require__(/*! ../visitor */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/visitor.js\");\n\n// Checks that all referenced rules exist.\nfunction reportUndefinedRules(ast) {\n  const check = visitor.build({\n    rule_ref(node) {\n      if (!asts.findRule(ast, node.name)) {\n        throw new GrammarError(\n          `Rule \"${node.name}\" is not defined`,\n          node.location\n        );\n      }\n    }\n  });\n\n  check(ast);\n}\n\nmodule.exports = reportUndefinedRules;\n\n\n//# sourceURL=webpack://maap-input-parser/./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/passes/report-undefined-rules.js?");

/***/ }),

/***/ "./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/stack.js":
/*!********************************************************************************************************!*\
  !*** ./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/stack.js ***!
  \********************************************************************************************************/
/***/ ((module) => {

eval("\n\n/** Utility class that helps generating code for C-like languages. */\nclass Stack {\n  /**\n   * Constructs the helper for tracking variable slots of the stack virtual machine\n   *\n   * @param {string} ruleName The name of rule that will be used in error messages\n   * @param {string} varName The prefix for generated names of variables\n   * @param {string} type The type of the variables. For JavaScript there are `var` or `let`\n   */\n  constructor(ruleName, varName, type) {\n    /** Last used variable in the stack. */\n    this.sp       = -1;\n    /** Maximum stack size. */\n    this.maxSp    = -1;\n    this.varName  = varName;\n    this.ruleName = ruleName;\n    this.type     = type;\n  }\n\n  /**\n   * Returns name of the variable at the index `i`.\n   *\n   * @param {number} i Index for which name must be generated\n   * @return {string} Generated name\n   *\n   * @throws {RangeError} If `i < 0`, which means a stack underflow (there are more `pop`s than `push`es)\n   */\n  name(i) {\n    if (i < 0) {\n      throw new RangeError(\n        `Rule '${this.ruleName}': The variable stack underflow: attempt to use a variable '${this.varName}<x>' at an index ${i}`\n      );\n    }\n\n    return this.varName + i;\n  }\n\n  /**\n   * Assigns `exprCode` to the new variable in the stack, returns generated code.\n   * As the result, the size of a stack increases on 1.\n   *\n   * @param {string} exprCode Any expression code that must be assigned to the new variable in the stack\n   * @return {string} Assignment code\n   */\n  push(exprCode) {\n    const code = this.name(++this.sp) + \" = \" + exprCode + \";\";\n\n    if (this.sp > this.maxSp) { this.maxSp = this.sp; }\n\n    return code;\n  }\n\n  /**\n   * Returns name or `n` names of the variable(s) from the top of the stack.\n   *\n   * @param {number} [n=1] Quantity of variables, which need to be removed from the stack\n   * @return {string|string[]} Generated name(s). If `n > 1` than array has length of `n`\n   *\n   * @throws {RangeError} If the stack underflow (there are more `pop`s than `push`es)\n   */\n  pop(n) {\n    if (n !== undefined) {\n      this.sp -= n;\n\n      return Array.from({ length: n }, (v, i) => this.name(this.sp + 1 + i));\n    }\n\n    return this.name(this.sp--);\n  }\n\n  /**\n   * Returns name of the first free variable. The same as `index(0)`.\n   *\n   * @return {string} Generated name\n   *\n   * @throws {RangeError} If the stack is empty (there was no `push`'s yet)\n   */\n  top() { return this.name(this.sp); }\n\n  /**\n   * Returns name of the variable at index `i`.\n   *\n   * @param {number} [i] Index of the variable from top of the stack\n   * @return {string} Generated name\n   *\n   * @throws {RangeError} If `i < 0` or more than the stack size\n   */\n  index(i) {\n    if (i < 0) {\n      throw new RangeError(\n        `Rule '${this.ruleName}': The variable stack overflow: attempt to get a variable at a negative index ${i}`\n      );\n    }\n\n    return this.name(this.sp - i);\n  }\n\n  /**\n   * Returns variable name that contains result (bottom of the stack).\n   *\n   * @return {string} Generated name\n   *\n   * @throws {RangeError} If the stack is empty (there was no `push`es yet)\n   */\n  result() {\n    if (this.maxSp < 0) {\n      throw new RangeError(\n        `Rule '${this.ruleName}': The variable stack is empty, can't get the result'`\n      );\n    }\n\n    return this.name(0);\n  }\n\n  /**\n   * Returns defines of all used variables.\n   *\n   * @return {string} Generated define variable expression with the type `this.type`.\n   *         If the stack is empty, returns empty string\n   */\n  defines() {\n    if (this.maxSp < 0) {\n      return \"\";\n    }\n\n    return this.type + \" \" + Array.from({ length: this.maxSp + 1 }, (v, i) => this.name(i)).join(\", \") + \";\";\n  }\n\n  /**\n   * Checks that code in the `generateIf` and `generateElse` move the stack pointer in the same way.\n   *\n   * @param {number} pos Opcode number for error messages\n   * @param {function()} generateIf First function that works with this stack\n   * @param {function()} [generateElse] Second function that works with this stack\n   * @return {undefined}\n   *\n   * @throws {Error} If `generateElse` is defined and the stack pointer moved differently in the\n   *         `generateIf` and `generateElse`\n   */\n  checkedIf(pos, generateIf, generateElse) {\n    const baseSp = this.sp;\n\n    generateIf();\n\n    if (generateElse) {\n      const thenSp = this.sp;\n\n      this.sp = baseSp;\n      generateElse();\n\n      if (thenSp !== this.sp) {\n        throw new Error(\n          \"Rule '\" + this.ruleName + \"', position \" + pos + \": \"\n          + \"Branches of a condition can't move the stack pointer differently \"\n          + \"(before: \" + baseSp + \", after then: \" + thenSp + \", after else: \" + this.sp + \").\"\n        );\n      }\n    }\n  }\n\n  /**\n   * Checks that code in the `generateBody` do not move stack pointer.\n   *\n   * @param {number} pos Opcode number for error messages\n   * @param {function()} generateBody Function that works with this stack\n   * @return {undefined}\n   *\n   * @throws {Error} If `generateBody` move the stack pointer (if it contains unbalanced `push`es and `pop`s)\n   */\n  checkedLoop(pos, generateBody) {\n    const baseSp = this.sp;\n\n    generateBody();\n\n    if (baseSp !== this.sp) {\n      throw new Error(\n        \"Rule '\" + this.ruleName + \"', position \" + pos + \": \"\n        + \"Body of a loop can't move the stack pointer \"\n        + \"(before: \" + baseSp + \", after: \" + this.sp + \").\"\n      );\n    }\n  }\n}\n\nmodule.exports = Stack;\n\n\n//# sourceURL=webpack://maap-input-parser/./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/stack.js?");

/***/ }),

/***/ "./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/visitor.js":
/*!**********************************************************************************************************!*\
  !*** ./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/visitor.js ***!
  \**********************************************************************************************************/
/***/ ((module) => {

eval("\n\n// Simple AST node visitor builder.\nconst visitor = {\n  build(functions) {\n    function visit(node, ...args) {\n      return functions[node.type](node, ...args);\n    }\n\n    function visitNop() {\n      // Do nothing.\n    }\n\n    function visitExpression(node, ...args) {\n      return visit(node.expression, ...args);\n    }\n\n    function visitChildren(property) {\n      return function(node, ...args) {\n        // We do not use .map() here, because if you need the result\n        // of applying visitor to children you probable also need to\n        // process it in some way, therefore you anyway have to override\n        // this method. If you do not needed that, we do not waste time\n        // and memory for creating the output array\n        node[property].forEach(child => visit(child, ...args));\n      };\n    }\n\n    const DEFAULT_FUNCTIONS = {\n      grammar(node, ...args) {\n        if (node.topLevelInitializer) {\n          visit(node.topLevelInitializer, ...args);\n        }\n\n        if (node.initializer) {\n          visit(node.initializer, ...args);\n        }\n\n        node.rules.forEach(rule => visit(rule, ...args));\n      },\n\n      top_level_initializer: visitNop,\n      initializer: visitNop,\n      rule: visitExpression,\n      named: visitExpression,\n      choice: visitChildren(\"alternatives\"),\n      action: visitExpression,\n      sequence: visitChildren(\"elements\"),\n      labeled: visitExpression,\n      text: visitExpression,\n      simple_and: visitExpression,\n      simple_not: visitExpression,\n      optional: visitExpression,\n      zero_or_more: visitExpression,\n      one_or_more: visitExpression,\n      group: visitExpression,\n      semantic_and: visitNop,\n      semantic_not: visitNop,\n      rule_ref: visitNop,\n      literal: visitNop,\n      class: visitNop,\n      any: visitNop\n    };\n\n    Object.keys(DEFAULT_FUNCTIONS).forEach(type => {\n      if (!Object.prototype.hasOwnProperty.call(functions, type)) {\n        functions[type] = DEFAULT_FUNCTIONS[type];\n      }\n    });\n\n    return visit;\n  }\n};\n\nmodule.exports = visitor;\n\n\n//# sourceURL=webpack://maap-input-parser/./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/visitor.js?");

/***/ }),

/***/ "./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/grammar-error.js":
/*!*******************************************************************************************************!*\
  !*** ./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/grammar-error.js ***!
  \*******************************************************************************************************/
/***/ ((module) => {

eval("\n\n// See: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n// This is roughly what typescript generates, it's not called after super(), where it's needed.\nconst setProtoOf = Object.setPrototypeOf\n  || ({ __proto__: [] } instanceof Array\n      && function(d, b) {\n        // eslint-disable-next-line no-proto\n        d.__proto__ = b;\n      })\n  || function(d, b) {\n    for (const p in b) {\n      if (Object.prototype.hasOwnProperty.call(b, p)) {\n        d[p] = b[p];\n      }\n    }\n  };\n\n// Thrown when the grammar contains an error.\nclass GrammarError extends Error {\n  constructor(message, location, diagnostics) {\n    super(message);\n    setProtoOf(this, GrammarError.prototype);\n    this.name = \"GrammarError\";\n    this.location = location;\n    if (diagnostics === undefined) {\n      diagnostics = [];\n    }\n    this.diagnostics = diagnostics;\n  }\n\n  toString() {\n    let str = super.toString();\n    if (this.location) {\n      str += \"\\n at \";\n      if ((this.location.source !== undefined)\n          && (this.location.source !== null)) {\n        str += `${this.location.source}:`;\n      }\n      str += `${this.location.start.line}:${this.location.start.column}`;\n    }\n    for (const diag of this.diagnostics) {\n      str += \"\\n from \";\n      if ((diag.location.source !== undefined)\n          && (diag.location.source !== null)) {\n        str += `${diag.location.source}:`;\n      }\n      str += `${diag.location.start.line}:${diag.location.start.column}: ${diag.message}`;\n    }\n\n    return str;\n  }\n\n  /**\n   * @typedef SourceText {source: any, text: string}\n   */\n  /**\n   * Format the error with associated sources.  The `location.source` should have\n   * a `toString()` representation in order the result to look nice. If source\n   * is `null` or `undefined`, it is skipped from the output\n   *\n   * Sample output:\n   * ```\n   * Error: Label \"head\" is already defined\n   *  --> examples/arithmetics.pegjs:15:17\n   *    |\n   * 15 |   = head:Factor head:(_ (\"*\" / \"/\") _ Factor)* {\n   *    |                 ^^^^\n   * note: Original label location\n   *  --> examples/arithmetics.pegjs:15:5\n   *    |\n   * 15 |   = head:Factor head:(_ (\"*\" / \"/\") _ Factor)* {\n   *    |     ^^^^\n   * ```\n   *\n   * @param {SourceText[]} sources mapping from location source to source text\n   *\n   * @returns {string} the formatted error\n   */\n  format(sources) {\n    const srcLines = sources.map(({ source, text }) => ({\n      source,\n      text: text.split(/\\r\\n|\\n|\\r/g)\n    }));\n\n    function entry(location, indent, message = \"\") {\n      let str = \"\";\n      const src = srcLines.find(({ source }) => source === location.source);\n      const s = location.start;\n      if (src) {\n        const e = location.end;\n        const line = src.text[s.line - 1];\n        const last = s.line === e.line ? e.column : line.length + 1;\n        if (message) {\n          str += `\\nnote: ${message}`;\n        }\n        str += `\n --> ${location.source}:${s.line}:${s.column}\n${\"\".padEnd(indent)} |\n${s.line.toString().padStart(indent)} | ${line}\n${\"\".padEnd(indent)} | ${\"\".padEnd(s.column - 1)}${\"\".padEnd(last - s.column, \"^\")}`;\n      } else {\n        str += `\\n at ${location.source}:${s.line}:${s.column}`;\n        if (message) {\n          str += `: ${message}`;\n        }\n      }\n\n      return str;\n    }\n\n    // Calculate maximum width of all lines\n    let maxLine;\n    if (this.location) {\n      maxLine = this.diagnostics.reduce(\n        (t, { location }) => Math.max(t, location.start.line),\n        this.location.start.line\n      );\n    } else {\n      maxLine = Math.max.apply(\n        null,\n        this.diagnostics.map(d => d.location.start.line)\n      );\n    }\n    maxLine = maxLine.toString().length;\n\n    let str = `Error: ${this.message}`;\n    if (this.location) {\n      str += entry(this.location, maxLine);\n    }\n    for (const diag of this.diagnostics) {\n      str += entry(diag.location, maxLine, diag.message);\n    }\n\n    return str;\n  }\n}\n\nmodule.exports = GrammarError;\n\n\n//# sourceURL=webpack://maap-input-parser/./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/grammar-error.js?");

/***/ }),

/***/ "./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/parser.js":
/*!************************************************************************************************!*\
  !*** ./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/parser.js ***!
  \************************************************************************************************/
/***/ ((module) => {

eval("// Generated by Peggy 1.2.0.\n//\n// https://peggyjs.org/\n\n\n\n\n  const OPS_TO_PREFIXED_TYPES = {\n    \"$\": \"text\",\n    \"&\": \"simple_and\",\n    \"!\": \"simple_not\"\n  };\n\n  const OPS_TO_SUFFIXED_TYPES = {\n    \"?\": \"optional\",\n    \"*\": \"zero_or_more\",\n    \"+\": \"one_or_more\"\n  };\n\n  const OPS_TO_SEMANTIC_PREDICATE_TYPES = {\n    \"&\": \"semantic_and\",\n    \"!\": \"semantic_not\"\n  };\n\n\nfunction peg$subclass(child, parent) {\n  function C() { this.constructor = child; }\n  C.prototype = parent.prototype;\n  child.prototype = new C();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  var self = Error.call(this, message);\n  if (Object.setPrototypeOf) {\n    Object.setPrototypeOf(self, peg$SyntaxError.prototype);\n  }\n  self.expected = expected;\n  self.found = found;\n  self.location = location;\n  self.name = \"SyntaxError\";\n  return self;\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\nfunction peg$padEnd(str, targetLength, padString) {\n  padString = padString || \" \";\n  if (str.length > targetLength) { return str; }\n  targetLength -= str.length;\n  padString += padString.repeat(targetLength);\n  return str + padString.slice(0, targetLength);\n}\n\npeg$SyntaxError.prototype.format = function(sources) {\n  var str = \"Error: \" + this.message;\n  if (this.location) {\n    var src = null;\n    var k;\n    for (k = 0; k < sources.length; k++) {\n      if (sources[k].source === this.location.source) {\n        src = sources[k].text.split(/\\r\\n|\\n|\\r/g);\n        break;\n      }\n    }\n    var s = this.location.start;\n    var loc = this.location.source + \":\" + s.line + \":\" + s.column;\n    if (src) {\n      var e = this.location.end;\n      var filler = peg$padEnd(\"\", s.line.toString().length);\n      var line = src[s.line - 1];\n      var last = s.line === e.line ? e.column : line.length + 1;\n      str += \"\\n --> \" + loc + \"\\n\"\n          + filler + \" |\\n\"\n          + s.line + \" | \" + line + \"\\n\"\n          + filler + \" | \" + peg$padEnd(\"\", s.column - 1)\n          + peg$padEnd(\"\", last - s.column, \"^\");\n    } else {\n      str += \"\\n at \" + loc;\n    }\n  }\n  return str;\n};\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n    literal: function(expectation) {\n      return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n    },\n\n    class: function(expectation) {\n      var escapedParts = expectation.parts.map(function(part) {\n        return Array.isArray(part)\n          ? classEscape(part[0]) + \"-\" + classEscape(part[1])\n          : classEscape(part);\n      });\n\n      return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n    },\n\n    any: function() {\n      return \"any character\";\n    },\n\n    end: function() {\n      return \"end of input\";\n    },\n\n    other: function(expectation) {\n      return expectation.description;\n    }\n  };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\"/g,  \"\\\\\\\"\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, \"\\\\\\\\\")\n      .replace(/\\]/g, \"\\\\]\")\n      .replace(/\\^/g, \"\\\\^\")\n      .replace(/-/g,  \"\\\\-\")\n      .replace(/\\0/g, \"\\\\0\")\n      .replace(/\\t/g, \"\\\\t\")\n      .replace(/\\n/g, \"\\\\n\")\n      .replace(/\\r/g, \"\\\\r\")\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return \"\\\\x0\" + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return \"\\\\x\"  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = expected.map(describeExpectation);\n    var i, j;\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== undefined ? options : {};\n\n  var peg$FAILED = {};\n  var peg$source = options.grammarSource;\n\n  var peg$startRuleFunctions = { Grammar: peg$parseGrammar };\n  var peg$startRuleFunction = peg$parseGrammar;\n\n  var peg$c0 = \"{\";\n  var peg$c1 = \"}\";\n  var peg$c2 = \"=\";\n  var peg$c3 = \"/\";\n  var peg$c4 = \"@\";\n  var peg$c5 = \":\";\n  var peg$c6 = \"$\";\n  var peg$c7 = \"&\";\n  var peg$c8 = \"!\";\n  var peg$c9 = \"?\";\n  var peg$c10 = \"*\";\n  var peg$c11 = \"+\";\n  var peg$c12 = \"(\";\n  var peg$c13 = \")\";\n  var peg$c14 = \"\\t\";\n  var peg$c15 = \"\\v\";\n  var peg$c16 = \"\\f\";\n  var peg$c17 = \" \";\n  var peg$c18 = \"\\xA0\";\n  var peg$c19 = \"\\uFEFF\";\n  var peg$c20 = \"\\n\";\n  var peg$c21 = \"\\r\\n\";\n  var peg$c22 = \"\\r\";\n  var peg$c23 = \"\\u2028\";\n  var peg$c24 = \"\\u2029\";\n  var peg$c25 = \"/*\";\n  var peg$c26 = \"*/\";\n  var peg$c27 = \"//\";\n  var peg$c28 = \"_\";\n  var peg$c29 = \"\\\\\";\n  var peg$c30 = \"\\u200C\";\n  var peg$c31 = \"\\u200D\";\n  var peg$c32 = \"i\";\n  var peg$c33 = \"\\\"\";\n  var peg$c34 = \"'\";\n  var peg$c35 = \"[\";\n  var peg$c36 = \"^\";\n  var peg$c37 = \"]\";\n  var peg$c38 = \"-\";\n  var peg$c39 = \"0\";\n  var peg$c40 = \"b\";\n  var peg$c41 = \"f\";\n  var peg$c42 = \"n\";\n  var peg$c43 = \"r\";\n  var peg$c44 = \"t\";\n  var peg$c45 = \"v\";\n  var peg$c46 = \"x\";\n  var peg$c47 = \"u\";\n  var peg$c48 = \".\";\n  var peg$c49 = \";\";\n\n  var peg$r0 = /^[\\n\\r\\u2028\\u2029]/;\n  var peg$r1 = /^[0-9]/;\n  var peg$r2 = /^[0-9a-f]/i;\n  var peg$r3 = /^[{}]/;\n  var peg$r4 = /^[a-z\\xB5\\xDF-\\xF6\\xF8-\\xFF\\u0101\\u0103\\u0105\\u0107\\u0109\\u010B\\u010D\\u010F\\u0111\\u0113\\u0115\\u0117\\u0119\\u011B\\u011D\\u011F\\u0121\\u0123\\u0125\\u0127\\u0129\\u012B\\u012D\\u012F\\u0131\\u0133\\u0135\\u0137-\\u0138\\u013A\\u013C\\u013E\\u0140\\u0142\\u0144\\u0146\\u0148-\\u0149\\u014B\\u014D\\u014F\\u0151\\u0153\\u0155\\u0157\\u0159\\u015B\\u015D\\u015F\\u0161\\u0163\\u0165\\u0167\\u0169\\u016B\\u016D\\u016F\\u0171\\u0173\\u0175\\u0177\\u017A\\u017C\\u017E-\\u0180\\u0183\\u0185\\u0188\\u018C-\\u018D\\u0192\\u0195\\u0199-\\u019B\\u019E\\u01A1\\u01A3\\u01A5\\u01A8\\u01AA-\\u01AB\\u01AD\\u01B0\\u01B4\\u01B6\\u01B9-\\u01BA\\u01BD-\\u01BF\\u01C6\\u01C9\\u01CC\\u01CE\\u01D0\\u01D2\\u01D4\\u01D6\\u01D8\\u01DA\\u01DC-\\u01DD\\u01DF\\u01E1\\u01E3\\u01E5\\u01E7\\u01E9\\u01EB\\u01ED\\u01EF-\\u01F0\\u01F3\\u01F5\\u01F9\\u01FB\\u01FD\\u01FF\\u0201\\u0203\\u0205\\u0207\\u0209\\u020B\\u020D\\u020F\\u0211\\u0213\\u0215\\u0217\\u0219\\u021B\\u021D\\u021F\\u0221\\u0223\\u0225\\u0227\\u0229\\u022B\\u022D\\u022F\\u0231\\u0233-\\u0239\\u023C\\u023F-\\u0240\\u0242\\u0247\\u0249\\u024B\\u024D\\u024F-\\u0293\\u0295-\\u02AF\\u0371\\u0373\\u0377\\u037B-\\u037D\\u0390\\u03AC-\\u03CE\\u03D0-\\u03D1\\u03D5-\\u03D7\\u03D9\\u03DB\\u03DD\\u03DF\\u03E1\\u03E3\\u03E5\\u03E7\\u03E9\\u03EB\\u03ED\\u03EF-\\u03F3\\u03F5\\u03F8\\u03FB-\\u03FC\\u0430-\\u045F\\u0461\\u0463\\u0465\\u0467\\u0469\\u046B\\u046D\\u046F\\u0471\\u0473\\u0475\\u0477\\u0479\\u047B\\u047D\\u047F\\u0481\\u048B\\u048D\\u048F\\u0491\\u0493\\u0495\\u0497\\u0499\\u049B\\u049D\\u049F\\u04A1\\u04A3\\u04A5\\u04A7\\u04A9\\u04AB\\u04AD\\u04AF\\u04B1\\u04B3\\u04B5\\u04B7\\u04B9\\u04BB\\u04BD\\u04BF\\u04C2\\u04C4\\u04C6\\u04C8\\u04CA\\u04CC\\u04CE-\\u04CF\\u04D1\\u04D3\\u04D5\\u04D7\\u04D9\\u04DB\\u04DD\\u04DF\\u04E1\\u04E3\\u04E5\\u04E7\\u04E9\\u04EB\\u04ED\\u04EF\\u04F1\\u04F3\\u04F5\\u04F7\\u04F9\\u04FB\\u04FD\\u04FF\\u0501\\u0503\\u0505\\u0507\\u0509\\u050B\\u050D\\u050F\\u0511\\u0513\\u0515\\u0517\\u0519\\u051B\\u051D\\u051F\\u0521\\u0523\\u0525\\u0527\\u0529\\u052B\\u052D\\u052F\\u0561-\\u0587\\u13F8-\\u13FD\\u1D00-\\u1D2B\\u1D6B-\\u1D77\\u1D79-\\u1D9A\\u1E01\\u1E03\\u1E05\\u1E07\\u1E09\\u1E0B\\u1E0D\\u1E0F\\u1E11\\u1E13\\u1E15\\u1E17\\u1E19\\u1E1B\\u1E1D\\u1E1F\\u1E21\\u1E23\\u1E25\\u1E27\\u1E29\\u1E2B\\u1E2D\\u1E2F\\u1E31\\u1E33\\u1E35\\u1E37\\u1E39\\u1E3B\\u1E3D\\u1E3F\\u1E41\\u1E43\\u1E45\\u1E47\\u1E49\\u1E4B\\u1E4D\\u1E4F\\u1E51\\u1E53\\u1E55\\u1E57\\u1E59\\u1E5B\\u1E5D\\u1E5F\\u1E61\\u1E63\\u1E65\\u1E67\\u1E69\\u1E6B\\u1E6D\\u1E6F\\u1E71\\u1E73\\u1E75\\u1E77\\u1E79\\u1E7B\\u1E7D\\u1E7F\\u1E81\\u1E83\\u1E85\\u1E87\\u1E89\\u1E8B\\u1E8D\\u1E8F\\u1E91\\u1E93\\u1E95-\\u1E9D\\u1E9F\\u1EA1\\u1EA3\\u1EA5\\u1EA7\\u1EA9\\u1EAB\\u1EAD\\u1EAF\\u1EB1\\u1EB3\\u1EB5\\u1EB7\\u1EB9\\u1EBB\\u1EBD\\u1EBF\\u1EC1\\u1EC3\\u1EC5\\u1EC7\\u1EC9\\u1ECB\\u1ECD\\u1ECF\\u1ED1\\u1ED3\\u1ED5\\u1ED7\\u1ED9\\u1EDB\\u1EDD\\u1EDF\\u1EE1\\u1EE3\\u1EE5\\u1EE7\\u1EE9\\u1EEB\\u1EED\\u1EEF\\u1EF1\\u1EF3\\u1EF5\\u1EF7\\u1EF9\\u1EFB\\u1EFD\\u1EFF-\\u1F07\\u1F10-\\u1F15\\u1F20-\\u1F27\\u1F30-\\u1F37\\u1F40-\\u1F45\\u1F50-\\u1F57\\u1F60-\\u1F67\\u1F70-\\u1F7D\\u1F80-\\u1F87\\u1F90-\\u1F97\\u1FA0-\\u1FA7\\u1FB0-\\u1FB4\\u1FB6-\\u1FB7\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FC7\\u1FD0-\\u1FD3\\u1FD6-\\u1FD7\\u1FE0-\\u1FE7\\u1FF2-\\u1FF4\\u1FF6-\\u1FF7\\u210A\\u210E-\\u210F\\u2113\\u212F\\u2134\\u2139\\u213C-\\u213D\\u2146-\\u2149\\u214E\\u2184\\u2C30-\\u2C5E\\u2C61\\u2C65-\\u2C66\\u2C68\\u2C6A\\u2C6C\\u2C71\\u2C73-\\u2C74\\u2C76-\\u2C7B\\u2C81\\u2C83\\u2C85\\u2C87\\u2C89\\u2C8B\\u2C8D\\u2C8F\\u2C91\\u2C93\\u2C95\\u2C97\\u2C99\\u2C9B\\u2C9D\\u2C9F\\u2CA1\\u2CA3\\u2CA5\\u2CA7\\u2CA9\\u2CAB\\u2CAD\\u2CAF\\u2CB1\\u2CB3\\u2CB5\\u2CB7\\u2CB9\\u2CBB\\u2CBD\\u2CBF\\u2CC1\\u2CC3\\u2CC5\\u2CC7\\u2CC9\\u2CCB\\u2CCD\\u2CCF\\u2CD1\\u2CD3\\u2CD5\\u2CD7\\u2CD9\\u2CDB\\u2CDD\\u2CDF\\u2CE1\\u2CE3-\\u2CE4\\u2CEC\\u2CEE\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\uA641\\uA643\\uA645\\uA647\\uA649\\uA64B\\uA64D\\uA64F\\uA651\\uA653\\uA655\\uA657\\uA659\\uA65B\\uA65D\\uA65F\\uA661\\uA663\\uA665\\uA667\\uA669\\uA66B\\uA66D\\uA681\\uA683\\uA685\\uA687\\uA689\\uA68B\\uA68D\\uA68F\\uA691\\uA693\\uA695\\uA697\\uA699\\uA69B\\uA723\\uA725\\uA727\\uA729\\uA72B\\uA72D\\uA72F-\\uA731\\uA733\\uA735\\uA737\\uA739\\uA73B\\uA73D\\uA73F\\uA741\\uA743\\uA745\\uA747\\uA749\\uA74B\\uA74D\\uA74F\\uA751\\uA753\\uA755\\uA757\\uA759\\uA75B\\uA75D\\uA75F\\uA761\\uA763\\uA765\\uA767\\uA769\\uA76B\\uA76D\\uA76F\\uA771-\\uA778\\uA77A\\uA77C\\uA77F\\uA781\\uA783\\uA785\\uA787\\uA78C\\uA78E\\uA791\\uA793-\\uA795\\uA797\\uA799\\uA79B\\uA79D\\uA79F\\uA7A1\\uA7A3\\uA7A5\\uA7A7\\uA7A9\\uA7B5\\uA7B7\\uA7FA\\uAB30-\\uAB5A\\uAB60-\\uAB65\\uAB70-\\uABBF\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFF41-\\uFF5A]/;\n  var peg$r5 = /^[\\u02B0-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0374\\u037A\\u0559\\u0640\\u06E5-\\u06E6\\u07F4-\\u07F5\\u07FA\\u081A\\u0824\\u0828\\u0971\\u0E46\\u0EC6\\u10FC\\u17D7\\u1843\\u1AA7\\u1C78-\\u1C7D\\u1D2C-\\u1D6A\\u1D78\\u1D9B-\\u1DBF\\u2071\\u207F\\u2090-\\u209C\\u2C7C-\\u2C7D\\u2D6F\\u2E2F\\u3005\\u3031-\\u3035\\u303B\\u309D-\\u309E\\u30FC-\\u30FE\\uA015\\uA4F8-\\uA4FD\\uA60C\\uA67F\\uA69C-\\uA69D\\uA717-\\uA71F\\uA770\\uA788\\uA7F8-\\uA7F9\\uA9CF\\uA9E6\\uAA70\\uAADD\\uAAF3-\\uAAF4\\uAB5C-\\uAB5F\\uFF70\\uFF9E-\\uFF9F]/;\n  var peg$r6 = /^[\\xAA\\xBA\\u01BB\\u01C0-\\u01C3\\u0294\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u063F\\u0641-\\u064A\\u066E-\\u066F\\u0671-\\u06D3\\u06D5\\u06EE-\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u0800-\\u0815\\u0840-\\u0858\\u08A0-\\u08B4\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0972-\\u0980\\u0985-\\u098C\\u098F-\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC-\\u09DD\\u09DF-\\u09E1\\u09F0-\\u09F1\\u0A05-\\u0A0A\\u0A0F-\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32-\\u0A33\\u0A35-\\u0A36\\u0A38-\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2-\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0-\\u0AE1\\u0AF9\\u0B05-\\u0B0C\\u0B0F-\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32-\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C-\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99-\\u0B9A\\u0B9C\\u0B9E-\\u0B9F\\u0BA3-\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58-\\u0C5A\\u0C60-\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0-\\u0CE1\\u0CF1-\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D5F-\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32-\\u0E33\\u0E40-\\u0E45\\u0E81-\\u0E82\\u0E84\\u0E87-\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA-\\u0EAB\\u0EAD-\\u0EB0\\u0EB2-\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065-\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10D0-\\u10FA\\u10FD-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16F1-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17DC\\u1820-\\u1842\\u1844-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE-\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C77\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5-\\u1CF6\\u2135-\\u2138\\u2D30-\\u2D67\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3006\\u303C\\u3041-\\u3096\\u309F\\u30A1-\\u30FA\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA000-\\uA014\\uA016-\\uA48C\\uA4D0-\\uA4F7\\uA500-\\uA60B\\uA610-\\uA61F\\uA62A-\\uA62B\\uA66E\\uA6A0-\\uA6E5\\uA78F\\uA7F7\\uA7FB-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA8FD\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9E0-\\uA9E4\\uA9E7-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA6F\\uAA71-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5-\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADC\\uAAE0-\\uAAEA\\uAAF2\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40-\\uFB41\\uFB43-\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF66-\\uFF6F\\uFF71-\\uFF9D\\uFFA0-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]/;\n  var peg$r7 = /^[\\u01C5\\u01C8\\u01CB\\u01F2\\u1F88-\\u1F8F\\u1F98-\\u1F9F\\u1FA8-\\u1FAF\\u1FBC\\u1FCC\\u1FFC]/;\n  var peg$r8 = /^[A-Z\\xC0-\\xD6\\xD8-\\xDE\\u0100\\u0102\\u0104\\u0106\\u0108\\u010A\\u010C\\u010E\\u0110\\u0112\\u0114\\u0116\\u0118\\u011A\\u011C\\u011E\\u0120\\u0122\\u0124\\u0126\\u0128\\u012A\\u012C\\u012E\\u0130\\u0132\\u0134\\u0136\\u0139\\u013B\\u013D\\u013F\\u0141\\u0143\\u0145\\u0147\\u014A\\u014C\\u014E\\u0150\\u0152\\u0154\\u0156\\u0158\\u015A\\u015C\\u015E\\u0160\\u0162\\u0164\\u0166\\u0168\\u016A\\u016C\\u016E\\u0170\\u0172\\u0174\\u0176\\u0178-\\u0179\\u017B\\u017D\\u0181-\\u0182\\u0184\\u0186-\\u0187\\u0189-\\u018B\\u018E-\\u0191\\u0193-\\u0194\\u0196-\\u0198\\u019C-\\u019D\\u019F-\\u01A0\\u01A2\\u01A4\\u01A6-\\u01A7\\u01A9\\u01AC\\u01AE-\\u01AF\\u01B1-\\u01B3\\u01B5\\u01B7-\\u01B8\\u01BC\\u01C4\\u01C7\\u01CA\\u01CD\\u01CF\\u01D1\\u01D3\\u01D5\\u01D7\\u01D9\\u01DB\\u01DE\\u01E0\\u01E2\\u01E4\\u01E6\\u01E8\\u01EA\\u01EC\\u01EE\\u01F1\\u01F4\\u01F6-\\u01F8\\u01FA\\u01FC\\u01FE\\u0200\\u0202\\u0204\\u0206\\u0208\\u020A\\u020C\\u020E\\u0210\\u0212\\u0214\\u0216\\u0218\\u021A\\u021C\\u021E\\u0220\\u0222\\u0224\\u0226\\u0228\\u022A\\u022C\\u022E\\u0230\\u0232\\u023A-\\u023B\\u023D-\\u023E\\u0241\\u0243-\\u0246\\u0248\\u024A\\u024C\\u024E\\u0370\\u0372\\u0376\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u038F\\u0391-\\u03A1\\u03A3-\\u03AB\\u03CF\\u03D2-\\u03D4\\u03D8\\u03DA\\u03DC\\u03DE\\u03E0\\u03E2\\u03E4\\u03E6\\u03E8\\u03EA\\u03EC\\u03EE\\u03F4\\u03F7\\u03F9-\\u03FA\\u03FD-\\u042F\\u0460\\u0462\\u0464\\u0466\\u0468\\u046A\\u046C\\u046E\\u0470\\u0472\\u0474\\u0476\\u0478\\u047A\\u047C\\u047E\\u0480\\u048A\\u048C\\u048E\\u0490\\u0492\\u0494\\u0496\\u0498\\u049A\\u049C\\u049E\\u04A0\\u04A2\\u04A4\\u04A6\\u04A8\\u04AA\\u04AC\\u04AE\\u04B0\\u04B2\\u04B4\\u04B6\\u04B8\\u04BA\\u04BC\\u04BE\\u04C0-\\u04C1\\u04C3\\u04C5\\u04C7\\u04C9\\u04CB\\u04CD\\u04D0\\u04D2\\u04D4\\u04D6\\u04D8\\u04DA\\u04DC\\u04DE\\u04E0\\u04E2\\u04E4\\u04E6\\u04E8\\u04EA\\u04EC\\u04EE\\u04F0\\u04F2\\u04F4\\u04F6\\u04F8\\u04FA\\u04FC\\u04FE\\u0500\\u0502\\u0504\\u0506\\u0508\\u050A\\u050C\\u050E\\u0510\\u0512\\u0514\\u0516\\u0518\\u051A\\u051C\\u051E\\u0520\\u0522\\u0524\\u0526\\u0528\\u052A\\u052C\\u052E\\u0531-\\u0556\\u10A0-\\u10C5\\u10C7\\u10CD\\u13A0-\\u13F5\\u1E00\\u1E02\\u1E04\\u1E06\\u1E08\\u1E0A\\u1E0C\\u1E0E\\u1E10\\u1E12\\u1E14\\u1E16\\u1E18\\u1E1A\\u1E1C\\u1E1E\\u1E20\\u1E22\\u1E24\\u1E26\\u1E28\\u1E2A\\u1E2C\\u1E2E\\u1E30\\u1E32\\u1E34\\u1E36\\u1E38\\u1E3A\\u1E3C\\u1E3E\\u1E40\\u1E42\\u1E44\\u1E46\\u1E48\\u1E4A\\u1E4C\\u1E4E\\u1E50\\u1E52\\u1E54\\u1E56\\u1E58\\u1E5A\\u1E5C\\u1E5E\\u1E60\\u1E62\\u1E64\\u1E66\\u1E68\\u1E6A\\u1E6C\\u1E6E\\u1E70\\u1E72\\u1E74\\u1E76\\u1E78\\u1E7A\\u1E7C\\u1E7E\\u1E80\\u1E82\\u1E84\\u1E86\\u1E88\\u1E8A\\u1E8C\\u1E8E\\u1E90\\u1E92\\u1E94\\u1E9E\\u1EA0\\u1EA2\\u1EA4\\u1EA6\\u1EA8\\u1EAA\\u1EAC\\u1EAE\\u1EB0\\u1EB2\\u1EB4\\u1EB6\\u1EB8\\u1EBA\\u1EBC\\u1EBE\\u1EC0\\u1EC2\\u1EC4\\u1EC6\\u1EC8\\u1ECA\\u1ECC\\u1ECE\\u1ED0\\u1ED2\\u1ED4\\u1ED6\\u1ED8\\u1EDA\\u1EDC\\u1EDE\\u1EE0\\u1EE2\\u1EE4\\u1EE6\\u1EE8\\u1EEA\\u1EEC\\u1EEE\\u1EF0\\u1EF2\\u1EF4\\u1EF6\\u1EF8\\u1EFA\\u1EFC\\u1EFE\\u1F08-\\u1F0F\\u1F18-\\u1F1D\\u1F28-\\u1F2F\\u1F38-\\u1F3F\\u1F48-\\u1F4D\\u1F59\\u1F5B\\u1F5D\\u1F5F\\u1F68-\\u1F6F\\u1FB8-\\u1FBB\\u1FC8-\\u1FCB\\u1FD8-\\u1FDB\\u1FE8-\\u1FEC\\u1FF8-\\u1FFB\\u2102\\u2107\\u210B-\\u210D\\u2110-\\u2112\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u2130-\\u2133\\u213E-\\u213F\\u2145\\u2183\\u2C00-\\u2C2E\\u2C60\\u2C62-\\u2C64\\u2C67\\u2C69\\u2C6B\\u2C6D-\\u2C70\\u2C72\\u2C75\\u2C7E-\\u2C80\\u2C82\\u2C84\\u2C86\\u2C88\\u2C8A\\u2C8C\\u2C8E\\u2C90\\u2C92\\u2C94\\u2C96\\u2C98\\u2C9A\\u2C9C\\u2C9E\\u2CA0\\u2CA2\\u2CA4\\u2CA6\\u2CA8\\u2CAA\\u2CAC\\u2CAE\\u2CB0\\u2CB2\\u2CB4\\u2CB6\\u2CB8\\u2CBA\\u2CBC\\u2CBE\\u2CC0\\u2CC2\\u2CC4\\u2CC6\\u2CC8\\u2CCA\\u2CCC\\u2CCE\\u2CD0\\u2CD2\\u2CD4\\u2CD6\\u2CD8\\u2CDA\\u2CDC\\u2CDE\\u2CE0\\u2CE2\\u2CEB\\u2CED\\u2CF2\\uA640\\uA642\\uA644\\uA646\\uA648\\uA64A\\uA64C\\uA64E\\uA650\\uA652\\uA654\\uA656\\uA658\\uA65A\\uA65C\\uA65E\\uA660\\uA662\\uA664\\uA666\\uA668\\uA66A\\uA66C\\uA680\\uA682\\uA684\\uA686\\uA688\\uA68A\\uA68C\\uA68E\\uA690\\uA692\\uA694\\uA696\\uA698\\uA69A\\uA722\\uA724\\uA726\\uA728\\uA72A\\uA72C\\uA72E\\uA732\\uA734\\uA736\\uA738\\uA73A\\uA73C\\uA73E\\uA740\\uA742\\uA744\\uA746\\uA748\\uA74A\\uA74C\\uA74E\\uA750\\uA752\\uA754\\uA756\\uA758\\uA75A\\uA75C\\uA75E\\uA760\\uA762\\uA764\\uA766\\uA768\\uA76A\\uA76C\\uA76E\\uA779\\uA77B\\uA77D-\\uA77E\\uA780\\uA782\\uA784\\uA786\\uA78B\\uA78D\\uA790\\uA792\\uA796\\uA798\\uA79A\\uA79C\\uA79E\\uA7A0\\uA7A2\\uA7A4\\uA7A6\\uA7A8\\uA7AA-\\uA7AD\\uA7B0-\\uA7B4\\uA7B6\\uFF21-\\uFF3A]/;\n  var peg$r9 = /^[\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E-\\u094F\\u0982-\\u0983\\u09BE-\\u09C0\\u09C7-\\u09C8\\u09CB-\\u09CC\\u09D7\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB-\\u0ACC\\u0B02-\\u0B03\\u0B3E\\u0B40\\u0B47-\\u0B48\\u0B4B-\\u0B4C\\u0B57\\u0BBE-\\u0BBF\\u0BC1-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0BD7\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82-\\u0C83\\u0CBE\\u0CC0-\\u0CC4\\u0CC7-\\u0CC8\\u0CCA-\\u0CCB\\u0CD5-\\u0CD6\\u0D02-\\u0D03\\u0D3E-\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D57\\u0D82-\\u0D83\\u0DCF-\\u0DD1\\u0DD8-\\u0DDF\\u0DF2-\\u0DF3\\u0F3E-\\u0F3F\\u0F7F\\u102B-\\u102C\\u1031\\u1038\\u103B-\\u103C\\u1056-\\u1057\\u1062-\\u1064\\u1067-\\u106D\\u1083-\\u1084\\u1087-\\u108C\\u108F\\u109A-\\u109C\\u17B6\\u17BE-\\u17C5\\u17C7-\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930-\\u1931\\u1933-\\u1938\\u1A19-\\u1A1A\\u1A55\\u1A57\\u1A61\\u1A63-\\u1A64\\u1A6D-\\u1A72\\u1B04\\u1B35\\u1B3B\\u1B3D-\\u1B41\\u1B43-\\u1B44\\u1B82\\u1BA1\\u1BA6-\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2-\\u1BF3\\u1C24-\\u1C2B\\u1C34-\\u1C35\\u1CE1\\u1CF2-\\u1CF3\\u302E-\\u302F\\uA823-\\uA824\\uA827\\uA880-\\uA881\\uA8B4-\\uA8C3\\uA952-\\uA953\\uA983\\uA9B4-\\uA9B5\\uA9BA-\\uA9BB\\uA9BD-\\uA9C0\\uAA2F-\\uAA30\\uAA33-\\uAA34\\uAA4D\\uAA7B\\uAA7D\\uAAEB\\uAAEE-\\uAAEF\\uAAF5\\uABE3-\\uABE4\\uABE6-\\uABE7\\uABE9-\\uABEA\\uABEC]/;\n  var peg$r10 = /^[\\u0300-\\u036F\\u0483-\\u0487\\u0591-\\u05BD\\u05BF\\u05C1-\\u05C2\\u05C4-\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7-\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962-\\u0963\\u0981\\u09BC\\u09C1-\\u09C4\\u09CD\\u09E2-\\u09E3\\u0A01-\\u0A02\\u0A3C\\u0A41-\\u0A42\\u0A47-\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70-\\u0A71\\u0A75\\u0A81-\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7-\\u0AC8\\u0ACD\\u0AE2-\\u0AE3\\u0B01\\u0B3C\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B56\\u0B62-\\u0B63\\u0B82\\u0BC0\\u0BCD\\u0C00\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55-\\u0C56\\u0C62-\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC6\\u0CCC-\\u0CCD\\u0CE2-\\u0CE3\\u0D01\\u0D41-\\u0D44\\u0D4D\\u0D62-\\u0D63\\u0DCA\\u0DD2-\\u0DD4\\u0DD6\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EB9\\u0EBB-\\u0EBC\\u0EC8-\\u0ECD\\u0F18-\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86-\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039-\\u103A\\u103D-\\u103E\\u1058-\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085-\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752-\\u1753\\u1772-\\u1773\\u17B4-\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u18A9\\u1920-\\u1922\\u1927-\\u1928\\u1932\\u1939-\\u193B\\u1A17-\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1ABD\\u1B00-\\u1B03\\u1B34\\u1B36-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80-\\u1B81\\u1BA2-\\u1BA5\\u1BA8-\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8-\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36-\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8-\\u1CF9\\u1DC0-\\u1DF5\\u1DFC-\\u1DFF\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302D\\u3099-\\u309A\\uA66F\\uA674-\\uA67D\\uA69E-\\uA69F\\uA6F0-\\uA6F1\\uA802\\uA806\\uA80B\\uA825-\\uA826\\uA8C4\\uA8E0-\\uA8F1\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9E5\\uAA29-\\uAA2E\\uAA31-\\uAA32\\uAA35-\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7-\\uAAB8\\uAABE-\\uAABF\\uAAC1\\uAAEC-\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F]/;\n  var peg$r11 = /^[0-9\\u0660-\\u0669\\u06F0-\\u06F9\\u07C0-\\u07C9\\u0966-\\u096F\\u09E6-\\u09EF\\u0A66-\\u0A6F\\u0AE6-\\u0AEF\\u0B66-\\u0B6F\\u0BE6-\\u0BEF\\u0C66-\\u0C6F\\u0CE6-\\u0CEF\\u0D66-\\u0D6F\\u0DE6-\\u0DEF\\u0E50-\\u0E59\\u0ED0-\\u0ED9\\u0F20-\\u0F29\\u1040-\\u1049\\u1090-\\u1099\\u17E0-\\u17E9\\u1810-\\u1819\\u1946-\\u194F\\u19D0-\\u19D9\\u1A80-\\u1A89\\u1A90-\\u1A99\\u1B50-\\u1B59\\u1BB0-\\u1BB9\\u1C40-\\u1C49\\u1C50-\\u1C59\\uA620-\\uA629\\uA8D0-\\uA8D9\\uA900-\\uA909\\uA9D0-\\uA9D9\\uA9F0-\\uA9F9\\uAA50-\\uAA59\\uABF0-\\uABF9\\uFF10-\\uFF19]/;\n  var peg$r12 = /^[\\u16EE-\\u16F0\\u2160-\\u2182\\u2185-\\u2188\\u3007\\u3021-\\u3029\\u3038-\\u303A\\uA6E6-\\uA6EF]/;\n  var peg$r13 = /^[_\\u203F-\\u2040\\u2054\\uFE33-\\uFE34\\uFE4D-\\uFE4F\\uFF3F]/;\n  var peg$r14 = /^[ \\xA0\\u1680\\u2000-\\u200A\\u202F\\u205F\\u3000]/;\n\n  var peg$e0 = peg$literalExpectation(\"{\", false);\n  var peg$e1 = peg$literalExpectation(\"}\", false);\n  var peg$e2 = peg$literalExpectation(\"=\", false);\n  var peg$e3 = peg$literalExpectation(\"/\", false);\n  var peg$e4 = peg$literalExpectation(\"@\", false);\n  var peg$e5 = peg$literalExpectation(\":\", false);\n  var peg$e6 = peg$literalExpectation(\"$\", false);\n  var peg$e7 = peg$literalExpectation(\"&\", false);\n  var peg$e8 = peg$literalExpectation(\"!\", false);\n  var peg$e9 = peg$literalExpectation(\"?\", false);\n  var peg$e10 = peg$literalExpectation(\"*\", false);\n  var peg$e11 = peg$literalExpectation(\"+\", false);\n  var peg$e12 = peg$literalExpectation(\"(\", false);\n  var peg$e13 = peg$literalExpectation(\")\", false);\n  var peg$e14 = peg$anyExpectation();\n  var peg$e15 = peg$otherExpectation(\"whitespace\");\n  var peg$e16 = peg$literalExpectation(\"\\t\", false);\n  var peg$e17 = peg$literalExpectation(\"\\v\", false);\n  var peg$e18 = peg$literalExpectation(\"\\f\", false);\n  var peg$e19 = peg$literalExpectation(\" \", false);\n  var peg$e20 = peg$literalExpectation(\"\\xA0\", false);\n  var peg$e21 = peg$literalExpectation(\"\\uFEFF\", false);\n  var peg$e22 = peg$classExpectation([\"\\n\", \"\\r\", \"\\u2028\", \"\\u2029\"], false, false);\n  var peg$e23 = peg$otherExpectation(\"end of line\");\n  var peg$e24 = peg$literalExpectation(\"\\n\", false);\n  var peg$e25 = peg$literalExpectation(\"\\r\\n\", false);\n  var peg$e26 = peg$literalExpectation(\"\\r\", false);\n  var peg$e27 = peg$literalExpectation(\"\\u2028\", false);\n  var peg$e28 = peg$literalExpectation(\"\\u2029\", false);\n  var peg$e29 = peg$otherExpectation(\"comment\");\n  var peg$e30 = peg$literalExpectation(\"/*\", false);\n  var peg$e31 = peg$literalExpectation(\"*/\", false);\n  var peg$e32 = peg$literalExpectation(\"//\", false);\n  var peg$e33 = peg$otherExpectation(\"identifier\");\n  var peg$e34 = peg$literalExpectation(\"_\", false);\n  var peg$e35 = peg$literalExpectation(\"\\\\\", false);\n  var peg$e36 = peg$literalExpectation(\"\\u200C\", false);\n  var peg$e37 = peg$literalExpectation(\"\\u200D\", false);\n  var peg$e38 = peg$otherExpectation(\"literal\");\n  var peg$e39 = peg$literalExpectation(\"i\", false);\n  var peg$e40 = peg$otherExpectation(\"string\");\n  var peg$e41 = peg$literalExpectation(\"\\\"\", false);\n  var peg$e42 = peg$literalExpectation(\"'\", false);\n  var peg$e43 = peg$otherExpectation(\"character class\");\n  var peg$e44 = peg$literalExpectation(\"[\", false);\n  var peg$e45 = peg$literalExpectation(\"^\", false);\n  var peg$e46 = peg$literalExpectation(\"]\", false);\n  var peg$e47 = peg$literalExpectation(\"-\", false);\n  var peg$e48 = peg$literalExpectation(\"0\", false);\n  var peg$e49 = peg$literalExpectation(\"b\", false);\n  var peg$e50 = peg$literalExpectation(\"f\", false);\n  var peg$e51 = peg$literalExpectation(\"n\", false);\n  var peg$e52 = peg$literalExpectation(\"r\", false);\n  var peg$e53 = peg$literalExpectation(\"t\", false);\n  var peg$e54 = peg$literalExpectation(\"v\", false);\n  var peg$e55 = peg$literalExpectation(\"x\", false);\n  var peg$e56 = peg$literalExpectation(\"u\", false);\n  var peg$e57 = peg$classExpectation([[\"0\", \"9\"]], false, false);\n  var peg$e58 = peg$classExpectation([[\"0\", \"9\"], [\"a\", \"f\"]], false, true);\n  var peg$e59 = peg$literalExpectation(\".\", false);\n  var peg$e60 = peg$otherExpectation(\"code block\");\n  var peg$e61 = peg$classExpectation([\"{\", \"}\"], false, false);\n  var peg$e62 = peg$classExpectation([[\"a\", \"z\"], \"\\xB5\", [\"\\xDF\", \"\\xF6\"], [\"\\xF8\", \"\\xFF\"], \"\\u0101\", \"\\u0103\", \"\\u0105\", \"\\u0107\", \"\\u0109\", \"\\u010B\", \"\\u010D\", \"\\u010F\", \"\\u0111\", \"\\u0113\", \"\\u0115\", \"\\u0117\", \"\\u0119\", \"\\u011B\", \"\\u011D\", \"\\u011F\", \"\\u0121\", \"\\u0123\", \"\\u0125\", \"\\u0127\", \"\\u0129\", \"\\u012B\", \"\\u012D\", \"\\u012F\", \"\\u0131\", \"\\u0133\", \"\\u0135\", [\"\\u0137\", \"\\u0138\"], \"\\u013A\", \"\\u013C\", \"\\u013E\", \"\\u0140\", \"\\u0142\", \"\\u0144\", \"\\u0146\", [\"\\u0148\", \"\\u0149\"], \"\\u014B\", \"\\u014D\", \"\\u014F\", \"\\u0151\", \"\\u0153\", \"\\u0155\", \"\\u0157\", \"\\u0159\", \"\\u015B\", \"\\u015D\", \"\\u015F\", \"\\u0161\", \"\\u0163\", \"\\u0165\", \"\\u0167\", \"\\u0169\", \"\\u016B\", \"\\u016D\", \"\\u016F\", \"\\u0171\", \"\\u0173\", \"\\u0175\", \"\\u0177\", \"\\u017A\", \"\\u017C\", [\"\\u017E\", \"\\u0180\"], \"\\u0183\", \"\\u0185\", \"\\u0188\", [\"\\u018C\", \"\\u018D\"], \"\\u0192\", \"\\u0195\", [\"\\u0199\", \"\\u019B\"], \"\\u019E\", \"\\u01A1\", \"\\u01A3\", \"\\u01A5\", \"\\u01A8\", [\"\\u01AA\", \"\\u01AB\"], \"\\u01AD\", \"\\u01B0\", \"\\u01B4\", \"\\u01B6\", [\"\\u01B9\", \"\\u01BA\"], [\"\\u01BD\", \"\\u01BF\"], \"\\u01C6\", \"\\u01C9\", \"\\u01CC\", \"\\u01CE\", \"\\u01D0\", \"\\u01D2\", \"\\u01D4\", \"\\u01D6\", \"\\u01D8\", \"\\u01DA\", [\"\\u01DC\", \"\\u01DD\"], \"\\u01DF\", \"\\u01E1\", \"\\u01E3\", \"\\u01E5\", \"\\u01E7\", \"\\u01E9\", \"\\u01EB\", \"\\u01ED\", [\"\\u01EF\", \"\\u01F0\"], \"\\u01F3\", \"\\u01F5\", \"\\u01F9\", \"\\u01FB\", \"\\u01FD\", \"\\u01FF\", \"\\u0201\", \"\\u0203\", \"\\u0205\", \"\\u0207\", \"\\u0209\", \"\\u020B\", \"\\u020D\", \"\\u020F\", \"\\u0211\", \"\\u0213\", \"\\u0215\", \"\\u0217\", \"\\u0219\", \"\\u021B\", \"\\u021D\", \"\\u021F\", \"\\u0221\", \"\\u0223\", \"\\u0225\", \"\\u0227\", \"\\u0229\", \"\\u022B\", \"\\u022D\", \"\\u022F\", \"\\u0231\", [\"\\u0233\", \"\\u0239\"], \"\\u023C\", [\"\\u023F\", \"\\u0240\"], \"\\u0242\", \"\\u0247\", \"\\u0249\", \"\\u024B\", \"\\u024D\", [\"\\u024F\", \"\\u0293\"], [\"\\u0295\", \"\\u02AF\"], \"\\u0371\", \"\\u0373\", \"\\u0377\", [\"\\u037B\", \"\\u037D\"], \"\\u0390\", [\"\\u03AC\", \"\\u03CE\"], [\"\\u03D0\", \"\\u03D1\"], [\"\\u03D5\", \"\\u03D7\"], \"\\u03D9\", \"\\u03DB\", \"\\u03DD\", \"\\u03DF\", \"\\u03E1\", \"\\u03E3\", \"\\u03E5\", \"\\u03E7\", \"\\u03E9\", \"\\u03EB\", \"\\u03ED\", [\"\\u03EF\", \"\\u03F3\"], \"\\u03F5\", \"\\u03F8\", [\"\\u03FB\", \"\\u03FC\"], [\"\\u0430\", \"\\u045F\"], \"\\u0461\", \"\\u0463\", \"\\u0465\", \"\\u0467\", \"\\u0469\", \"\\u046B\", \"\\u046D\", \"\\u046F\", \"\\u0471\", \"\\u0473\", \"\\u0475\", \"\\u0477\", \"\\u0479\", \"\\u047B\", \"\\u047D\", \"\\u047F\", \"\\u0481\", \"\\u048B\", \"\\u048D\", \"\\u048F\", \"\\u0491\", \"\\u0493\", \"\\u0495\", \"\\u0497\", \"\\u0499\", \"\\u049B\", \"\\u049D\", \"\\u049F\", \"\\u04A1\", \"\\u04A3\", \"\\u04A5\", \"\\u04A7\", \"\\u04A9\", \"\\u04AB\", \"\\u04AD\", \"\\u04AF\", \"\\u04B1\", \"\\u04B3\", \"\\u04B5\", \"\\u04B7\", \"\\u04B9\", \"\\u04BB\", \"\\u04BD\", \"\\u04BF\", \"\\u04C2\", \"\\u04C4\", \"\\u04C6\", \"\\u04C8\", \"\\u04CA\", \"\\u04CC\", [\"\\u04CE\", \"\\u04CF\"], \"\\u04D1\", \"\\u04D3\", \"\\u04D5\", \"\\u04D7\", \"\\u04D9\", \"\\u04DB\", \"\\u04DD\", \"\\u04DF\", \"\\u04E1\", \"\\u04E3\", \"\\u04E5\", \"\\u04E7\", \"\\u04E9\", \"\\u04EB\", \"\\u04ED\", \"\\u04EF\", \"\\u04F1\", \"\\u04F3\", \"\\u04F5\", \"\\u04F7\", \"\\u04F9\", \"\\u04FB\", \"\\u04FD\", \"\\u04FF\", \"\\u0501\", \"\\u0503\", \"\\u0505\", \"\\u0507\", \"\\u0509\", \"\\u050B\", \"\\u050D\", \"\\u050F\", \"\\u0511\", \"\\u0513\", \"\\u0515\", \"\\u0517\", \"\\u0519\", \"\\u051B\", \"\\u051D\", \"\\u051F\", \"\\u0521\", \"\\u0523\", \"\\u0525\", \"\\u0527\", \"\\u0529\", \"\\u052B\", \"\\u052D\", \"\\u052F\", [\"\\u0561\", \"\\u0587\"], [\"\\u13F8\", \"\\u13FD\"], [\"\\u1D00\", \"\\u1D2B\"], [\"\\u1D6B\", \"\\u1D77\"], [\"\\u1D79\", \"\\u1D9A\"], \"\\u1E01\", \"\\u1E03\", \"\\u1E05\", \"\\u1E07\", \"\\u1E09\", \"\\u1E0B\", \"\\u1E0D\", \"\\u1E0F\", \"\\u1E11\", \"\\u1E13\", \"\\u1E15\", \"\\u1E17\", \"\\u1E19\", \"\\u1E1B\", \"\\u1E1D\", \"\\u1E1F\", \"\\u1E21\", \"\\u1E23\", \"\\u1E25\", \"\\u1E27\", \"\\u1E29\", \"\\u1E2B\", \"\\u1E2D\", \"\\u1E2F\", \"\\u1E31\", \"\\u1E33\", \"\\u1E35\", \"\\u1E37\", \"\\u1E39\", \"\\u1E3B\", \"\\u1E3D\", \"\\u1E3F\", \"\\u1E41\", \"\\u1E43\", \"\\u1E45\", \"\\u1E47\", \"\\u1E49\", \"\\u1E4B\", \"\\u1E4D\", \"\\u1E4F\", \"\\u1E51\", \"\\u1E53\", \"\\u1E55\", \"\\u1E57\", \"\\u1E59\", \"\\u1E5B\", \"\\u1E5D\", \"\\u1E5F\", \"\\u1E61\", \"\\u1E63\", \"\\u1E65\", \"\\u1E67\", \"\\u1E69\", \"\\u1E6B\", \"\\u1E6D\", \"\\u1E6F\", \"\\u1E71\", \"\\u1E73\", \"\\u1E75\", \"\\u1E77\", \"\\u1E79\", \"\\u1E7B\", \"\\u1E7D\", \"\\u1E7F\", \"\\u1E81\", \"\\u1E83\", \"\\u1E85\", \"\\u1E87\", \"\\u1E89\", \"\\u1E8B\", \"\\u1E8D\", \"\\u1E8F\", \"\\u1E91\", \"\\u1E93\", [\"\\u1E95\", \"\\u1E9D\"], \"\\u1E9F\", \"\\u1EA1\", \"\\u1EA3\", \"\\u1EA5\", \"\\u1EA7\", \"\\u1EA9\", \"\\u1EAB\", \"\\u1EAD\", \"\\u1EAF\", \"\\u1EB1\", \"\\u1EB3\", \"\\u1EB5\", \"\\u1EB7\", \"\\u1EB9\", \"\\u1EBB\", \"\\u1EBD\", \"\\u1EBF\", \"\\u1EC1\", \"\\u1EC3\", \"\\u1EC5\", \"\\u1EC7\", \"\\u1EC9\", \"\\u1ECB\", \"\\u1ECD\", \"\\u1ECF\", \"\\u1ED1\", \"\\u1ED3\", \"\\u1ED5\", \"\\u1ED7\", \"\\u1ED9\", \"\\u1EDB\", \"\\u1EDD\", \"\\u1EDF\", \"\\u1EE1\", \"\\u1EE3\", \"\\u1EE5\", \"\\u1EE7\", \"\\u1EE9\", \"\\u1EEB\", \"\\u1EED\", \"\\u1EEF\", \"\\u1EF1\", \"\\u1EF3\", \"\\u1EF5\", \"\\u1EF7\", \"\\u1EF9\", \"\\u1EFB\", \"\\u1EFD\", [\"\\u1EFF\", \"\\u1F07\"], [\"\\u1F10\", \"\\u1F15\"], [\"\\u1F20\", \"\\u1F27\"], [\"\\u1F30\", \"\\u1F37\"], [\"\\u1F40\", \"\\u1F45\"], [\"\\u1F50\", \"\\u1F57\"], [\"\\u1F60\", \"\\u1F67\"], [\"\\u1F70\", \"\\u1F7D\"], [\"\\u1F80\", \"\\u1F87\"], [\"\\u1F90\", \"\\u1F97\"], [\"\\u1FA0\", \"\\u1FA7\"], [\"\\u1FB0\", \"\\u1FB4\"], [\"\\u1FB6\", \"\\u1FB7\"], \"\\u1FBE\", [\"\\u1FC2\", \"\\u1FC4\"], [\"\\u1FC6\", \"\\u1FC7\"], [\"\\u1FD0\", \"\\u1FD3\"], [\"\\u1FD6\", \"\\u1FD7\"], [\"\\u1FE0\", \"\\u1FE7\"], [\"\\u1FF2\", \"\\u1FF4\"], [\"\\u1FF6\", \"\\u1FF7\"], \"\\u210A\", [\"\\u210E\", \"\\u210F\"], \"\\u2113\", \"\\u212F\", \"\\u2134\", \"\\u2139\", [\"\\u213C\", \"\\u213D\"], [\"\\u2146\", \"\\u2149\"], \"\\u214E\", \"\\u2184\", [\"\\u2C30\", \"\\u2C5E\"], \"\\u2C61\", [\"\\u2C65\", \"\\u2C66\"], \"\\u2C68\", \"\\u2C6A\", \"\\u2C6C\", \"\\u2C71\", [\"\\u2C73\", \"\\u2C74\"], [\"\\u2C76\", \"\\u2C7B\"], \"\\u2C81\", \"\\u2C83\", \"\\u2C85\", \"\\u2C87\", \"\\u2C89\", \"\\u2C8B\", \"\\u2C8D\", \"\\u2C8F\", \"\\u2C91\", \"\\u2C93\", \"\\u2C95\", \"\\u2C97\", \"\\u2C99\", \"\\u2C9B\", \"\\u2C9D\", \"\\u2C9F\", \"\\u2CA1\", \"\\u2CA3\", \"\\u2CA5\", \"\\u2CA7\", \"\\u2CA9\", \"\\u2CAB\", \"\\u2CAD\", \"\\u2CAF\", \"\\u2CB1\", \"\\u2CB3\", \"\\u2CB5\", \"\\u2CB7\", \"\\u2CB9\", \"\\u2CBB\", \"\\u2CBD\", \"\\u2CBF\", \"\\u2CC1\", \"\\u2CC3\", \"\\u2CC5\", \"\\u2CC7\", \"\\u2CC9\", \"\\u2CCB\", \"\\u2CCD\", \"\\u2CCF\", \"\\u2CD1\", \"\\u2CD3\", \"\\u2CD5\", \"\\u2CD7\", \"\\u2CD9\", \"\\u2CDB\", \"\\u2CDD\", \"\\u2CDF\", \"\\u2CE1\", [\"\\u2CE3\", \"\\u2CE4\"], \"\\u2CEC\", \"\\u2CEE\", \"\\u2CF3\", [\"\\u2D00\", \"\\u2D25\"], \"\\u2D27\", \"\\u2D2D\", \"\\uA641\", \"\\uA643\", \"\\uA645\", \"\\uA647\", \"\\uA649\", \"\\uA64B\", \"\\uA64D\", \"\\uA64F\", \"\\uA651\", \"\\uA653\", \"\\uA655\", \"\\uA657\", \"\\uA659\", \"\\uA65B\", \"\\uA65D\", \"\\uA65F\", \"\\uA661\", \"\\uA663\", \"\\uA665\", \"\\uA667\", \"\\uA669\", \"\\uA66B\", \"\\uA66D\", \"\\uA681\", \"\\uA683\", \"\\uA685\", \"\\uA687\", \"\\uA689\", \"\\uA68B\", \"\\uA68D\", \"\\uA68F\", \"\\uA691\", \"\\uA693\", \"\\uA695\", \"\\uA697\", \"\\uA699\", \"\\uA69B\", \"\\uA723\", \"\\uA725\", \"\\uA727\", \"\\uA729\", \"\\uA72B\", \"\\uA72D\", [\"\\uA72F\", \"\\uA731\"], \"\\uA733\", \"\\uA735\", \"\\uA737\", \"\\uA739\", \"\\uA73B\", \"\\uA73D\", \"\\uA73F\", \"\\uA741\", \"\\uA743\", \"\\uA745\", \"\\uA747\", \"\\uA749\", \"\\uA74B\", \"\\uA74D\", \"\\uA74F\", \"\\uA751\", \"\\uA753\", \"\\uA755\", \"\\uA757\", \"\\uA759\", \"\\uA75B\", \"\\uA75D\", \"\\uA75F\", \"\\uA761\", \"\\uA763\", \"\\uA765\", \"\\uA767\", \"\\uA769\", \"\\uA76B\", \"\\uA76D\", \"\\uA76F\", [\"\\uA771\", \"\\uA778\"], \"\\uA77A\", \"\\uA77C\", \"\\uA77F\", \"\\uA781\", \"\\uA783\", \"\\uA785\", \"\\uA787\", \"\\uA78C\", \"\\uA78E\", \"\\uA791\", [\"\\uA793\", \"\\uA795\"], \"\\uA797\", \"\\uA799\", \"\\uA79B\", \"\\uA79D\", \"\\uA79F\", \"\\uA7A1\", \"\\uA7A3\", \"\\uA7A5\", \"\\uA7A7\", \"\\uA7A9\", \"\\uA7B5\", \"\\uA7B7\", \"\\uA7FA\", [\"\\uAB30\", \"\\uAB5A\"], [\"\\uAB60\", \"\\uAB65\"], [\"\\uAB70\", \"\\uABBF\"], [\"\\uFB00\", \"\\uFB06\"], [\"\\uFB13\", \"\\uFB17\"], [\"\\uFF41\", \"\\uFF5A\"]], false, false);\n  var peg$e63 = peg$classExpectation([[\"\\u02B0\", \"\\u02C1\"], [\"\\u02C6\", \"\\u02D1\"], [\"\\u02E0\", \"\\u02E4\"], \"\\u02EC\", \"\\u02EE\", \"\\u0374\", \"\\u037A\", \"\\u0559\", \"\\u0640\", [\"\\u06E5\", \"\\u06E6\"], [\"\\u07F4\", \"\\u07F5\"], \"\\u07FA\", \"\\u081A\", \"\\u0824\", \"\\u0828\", \"\\u0971\", \"\\u0E46\", \"\\u0EC6\", \"\\u10FC\", \"\\u17D7\", \"\\u1843\", \"\\u1AA7\", [\"\\u1C78\", \"\\u1C7D\"], [\"\\u1D2C\", \"\\u1D6A\"], \"\\u1D78\", [\"\\u1D9B\", \"\\u1DBF\"], \"\\u2071\", \"\\u207F\", [\"\\u2090\", \"\\u209C\"], [\"\\u2C7C\", \"\\u2C7D\"], \"\\u2D6F\", \"\\u2E2F\", \"\\u3005\", [\"\\u3031\", \"\\u3035\"], \"\\u303B\", [\"\\u309D\", \"\\u309E\"], [\"\\u30FC\", \"\\u30FE\"], \"\\uA015\", [\"\\uA4F8\", \"\\uA4FD\"], \"\\uA60C\", \"\\uA67F\", [\"\\uA69C\", \"\\uA69D\"], [\"\\uA717\", \"\\uA71F\"], \"\\uA770\", \"\\uA788\", [\"\\uA7F8\", \"\\uA7F9\"], \"\\uA9CF\", \"\\uA9E6\", \"\\uAA70\", \"\\uAADD\", [\"\\uAAF3\", \"\\uAAF4\"], [\"\\uAB5C\", \"\\uAB5F\"], \"\\uFF70\", [\"\\uFF9E\", \"\\uFF9F\"]], false, false);\n  var peg$e64 = peg$classExpectation([\"\\xAA\", \"\\xBA\", \"\\u01BB\", [\"\\u01C0\", \"\\u01C3\"], \"\\u0294\", [\"\\u05D0\", \"\\u05EA\"], [\"\\u05F0\", \"\\u05F2\"], [\"\\u0620\", \"\\u063F\"], [\"\\u0641\", \"\\u064A\"], [\"\\u066E\", \"\\u066F\"], [\"\\u0671\", \"\\u06D3\"], \"\\u06D5\", [\"\\u06EE\", \"\\u06EF\"], [\"\\u06FA\", \"\\u06FC\"], \"\\u06FF\", \"\\u0710\", [\"\\u0712\", \"\\u072F\"], [\"\\u074D\", \"\\u07A5\"], \"\\u07B1\", [\"\\u07CA\", \"\\u07EA\"], [\"\\u0800\", \"\\u0815\"], [\"\\u0840\", \"\\u0858\"], [\"\\u08A0\", \"\\u08B4\"], [\"\\u0904\", \"\\u0939\"], \"\\u093D\", \"\\u0950\", [\"\\u0958\", \"\\u0961\"], [\"\\u0972\", \"\\u0980\"], [\"\\u0985\", \"\\u098C\"], [\"\\u098F\", \"\\u0990\"], [\"\\u0993\", \"\\u09A8\"], [\"\\u09AA\", \"\\u09B0\"], \"\\u09B2\", [\"\\u09B6\", \"\\u09B9\"], \"\\u09BD\", \"\\u09CE\", [\"\\u09DC\", \"\\u09DD\"], [\"\\u09DF\", \"\\u09E1\"], [\"\\u09F0\", \"\\u09F1\"], [\"\\u0A05\", \"\\u0A0A\"], [\"\\u0A0F\", \"\\u0A10\"], [\"\\u0A13\", \"\\u0A28\"], [\"\\u0A2A\", \"\\u0A30\"], [\"\\u0A32\", \"\\u0A33\"], [\"\\u0A35\", \"\\u0A36\"], [\"\\u0A38\", \"\\u0A39\"], [\"\\u0A59\", \"\\u0A5C\"], \"\\u0A5E\", [\"\\u0A72\", \"\\u0A74\"], [\"\\u0A85\", \"\\u0A8D\"], [\"\\u0A8F\", \"\\u0A91\"], [\"\\u0A93\", \"\\u0AA8\"], [\"\\u0AAA\", \"\\u0AB0\"], [\"\\u0AB2\", \"\\u0AB3\"], [\"\\u0AB5\", \"\\u0AB9\"], \"\\u0ABD\", \"\\u0AD0\", [\"\\u0AE0\", \"\\u0AE1\"], \"\\u0AF9\", [\"\\u0B05\", \"\\u0B0C\"], [\"\\u0B0F\", \"\\u0B10\"], [\"\\u0B13\", \"\\u0B28\"], [\"\\u0B2A\", \"\\u0B30\"], [\"\\u0B32\", \"\\u0B33\"], [\"\\u0B35\", \"\\u0B39\"], \"\\u0B3D\", [\"\\u0B5C\", \"\\u0B5D\"], [\"\\u0B5F\", \"\\u0B61\"], \"\\u0B71\", \"\\u0B83\", [\"\\u0B85\", \"\\u0B8A\"], [\"\\u0B8E\", \"\\u0B90\"], [\"\\u0B92\", \"\\u0B95\"], [\"\\u0B99\", \"\\u0B9A\"], \"\\u0B9C\", [\"\\u0B9E\", \"\\u0B9F\"], [\"\\u0BA3\", \"\\u0BA4\"], [\"\\u0BA8\", \"\\u0BAA\"], [\"\\u0BAE\", \"\\u0BB9\"], \"\\u0BD0\", [\"\\u0C05\", \"\\u0C0C\"], [\"\\u0C0E\", \"\\u0C10\"], [\"\\u0C12\", \"\\u0C28\"], [\"\\u0C2A\", \"\\u0C39\"], \"\\u0C3D\", [\"\\u0C58\", \"\\u0C5A\"], [\"\\u0C60\", \"\\u0C61\"], [\"\\u0C85\", \"\\u0C8C\"], [\"\\u0C8E\", \"\\u0C90\"], [\"\\u0C92\", \"\\u0CA8\"], [\"\\u0CAA\", \"\\u0CB3\"], [\"\\u0CB5\", \"\\u0CB9\"], \"\\u0CBD\", \"\\u0CDE\", [\"\\u0CE0\", \"\\u0CE1\"], [\"\\u0CF1\", \"\\u0CF2\"], [\"\\u0D05\", \"\\u0D0C\"], [\"\\u0D0E\", \"\\u0D10\"], [\"\\u0D12\", \"\\u0D3A\"], \"\\u0D3D\", \"\\u0D4E\", [\"\\u0D5F\", \"\\u0D61\"], [\"\\u0D7A\", \"\\u0D7F\"], [\"\\u0D85\", \"\\u0D96\"], [\"\\u0D9A\", \"\\u0DB1\"], [\"\\u0DB3\", \"\\u0DBB\"], \"\\u0DBD\", [\"\\u0DC0\", \"\\u0DC6\"], [\"\\u0E01\", \"\\u0E30\"], [\"\\u0E32\", \"\\u0E33\"], [\"\\u0E40\", \"\\u0E45\"], [\"\\u0E81\", \"\\u0E82\"], \"\\u0E84\", [\"\\u0E87\", \"\\u0E88\"], \"\\u0E8A\", \"\\u0E8D\", [\"\\u0E94\", \"\\u0E97\"], [\"\\u0E99\", \"\\u0E9F\"], [\"\\u0EA1\", \"\\u0EA3\"], \"\\u0EA5\", \"\\u0EA7\", [\"\\u0EAA\", \"\\u0EAB\"], [\"\\u0EAD\", \"\\u0EB0\"], [\"\\u0EB2\", \"\\u0EB3\"], \"\\u0EBD\", [\"\\u0EC0\", \"\\u0EC4\"], [\"\\u0EDC\", \"\\u0EDF\"], \"\\u0F00\", [\"\\u0F40\", \"\\u0F47\"], [\"\\u0F49\", \"\\u0F6C\"], [\"\\u0F88\", \"\\u0F8C\"], [\"\\u1000\", \"\\u102A\"], \"\\u103F\", [\"\\u1050\", \"\\u1055\"], [\"\\u105A\", \"\\u105D\"], \"\\u1061\", [\"\\u1065\", \"\\u1066\"], [\"\\u106E\", \"\\u1070\"], [\"\\u1075\", \"\\u1081\"], \"\\u108E\", [\"\\u10D0\", \"\\u10FA\"], [\"\\u10FD\", \"\\u1248\"], [\"\\u124A\", \"\\u124D\"], [\"\\u1250\", \"\\u1256\"], \"\\u1258\", [\"\\u125A\", \"\\u125D\"], [\"\\u1260\", \"\\u1288\"], [\"\\u128A\", \"\\u128D\"], [\"\\u1290\", \"\\u12B0\"], [\"\\u12B2\", \"\\u12B5\"], [\"\\u12B8\", \"\\u12BE\"], \"\\u12C0\", [\"\\u12C2\", \"\\u12C5\"], [\"\\u12C8\", \"\\u12D6\"], [\"\\u12D8\", \"\\u1310\"], [\"\\u1312\", \"\\u1315\"], [\"\\u1318\", \"\\u135A\"], [\"\\u1380\", \"\\u138F\"], [\"\\u1401\", \"\\u166C\"], [\"\\u166F\", \"\\u167F\"], [\"\\u1681\", \"\\u169A\"], [\"\\u16A0\", \"\\u16EA\"], [\"\\u16F1\", \"\\u16F8\"], [\"\\u1700\", \"\\u170C\"], [\"\\u170E\", \"\\u1711\"], [\"\\u1720\", \"\\u1731\"], [\"\\u1740\", \"\\u1751\"], [\"\\u1760\", \"\\u176C\"], [\"\\u176E\", \"\\u1770\"], [\"\\u1780\", \"\\u17B3\"], \"\\u17DC\", [\"\\u1820\", \"\\u1842\"], [\"\\u1844\", \"\\u1877\"], [\"\\u1880\", \"\\u18A8\"], \"\\u18AA\", [\"\\u18B0\", \"\\u18F5\"], [\"\\u1900\", \"\\u191E\"], [\"\\u1950\", \"\\u196D\"], [\"\\u1970\", \"\\u1974\"], [\"\\u1980\", \"\\u19AB\"], [\"\\u19B0\", \"\\u19C9\"], [\"\\u1A00\", \"\\u1A16\"], [\"\\u1A20\", \"\\u1A54\"], [\"\\u1B05\", \"\\u1B33\"], [\"\\u1B45\", \"\\u1B4B\"], [\"\\u1B83\", \"\\u1BA0\"], [\"\\u1BAE\", \"\\u1BAF\"], [\"\\u1BBA\", \"\\u1BE5\"], [\"\\u1C00\", \"\\u1C23\"], [\"\\u1C4D\", \"\\u1C4F\"], [\"\\u1C5A\", \"\\u1C77\"], [\"\\u1CE9\", \"\\u1CEC\"], [\"\\u1CEE\", \"\\u1CF1\"], [\"\\u1CF5\", \"\\u1CF6\"], [\"\\u2135\", \"\\u2138\"], [\"\\u2D30\", \"\\u2D67\"], [\"\\u2D80\", \"\\u2D96\"], [\"\\u2DA0\", \"\\u2DA6\"], [\"\\u2DA8\", \"\\u2DAE\"], [\"\\u2DB0\", \"\\u2DB6\"], [\"\\u2DB8\", \"\\u2DBE\"], [\"\\u2DC0\", \"\\u2DC6\"], [\"\\u2DC8\", \"\\u2DCE\"], [\"\\u2DD0\", \"\\u2DD6\"], [\"\\u2DD8\", \"\\u2DDE\"], \"\\u3006\", \"\\u303C\", [\"\\u3041\", \"\\u3096\"], \"\\u309F\", [\"\\u30A1\", \"\\u30FA\"], \"\\u30FF\", [\"\\u3105\", \"\\u312D\"], [\"\\u3131\", \"\\u318E\"], [\"\\u31A0\", \"\\u31BA\"], [\"\\u31F0\", \"\\u31FF\"], [\"\\u3400\", \"\\u4DB5\"], [\"\\u4E00\", \"\\u9FD5\"], [\"\\uA000\", \"\\uA014\"], [\"\\uA016\", \"\\uA48C\"], [\"\\uA4D0\", \"\\uA4F7\"], [\"\\uA500\", \"\\uA60B\"], [\"\\uA610\", \"\\uA61F\"], [\"\\uA62A\", \"\\uA62B\"], \"\\uA66E\", [\"\\uA6A0\", \"\\uA6E5\"], \"\\uA78F\", \"\\uA7F7\", [\"\\uA7FB\", \"\\uA801\"], [\"\\uA803\", \"\\uA805\"], [\"\\uA807\", \"\\uA80A\"], [\"\\uA80C\", \"\\uA822\"], [\"\\uA840\", \"\\uA873\"], [\"\\uA882\", \"\\uA8B3\"], [\"\\uA8F2\", \"\\uA8F7\"], \"\\uA8FB\", \"\\uA8FD\", [\"\\uA90A\", \"\\uA925\"], [\"\\uA930\", \"\\uA946\"], [\"\\uA960\", \"\\uA97C\"], [\"\\uA984\", \"\\uA9B2\"], [\"\\uA9E0\", \"\\uA9E4\"], [\"\\uA9E7\", \"\\uA9EF\"], [\"\\uA9FA\", \"\\uA9FE\"], [\"\\uAA00\", \"\\uAA28\"], [\"\\uAA40\", \"\\uAA42\"], [\"\\uAA44\", \"\\uAA4B\"], [\"\\uAA60\", \"\\uAA6F\"], [\"\\uAA71\", \"\\uAA76\"], \"\\uAA7A\", [\"\\uAA7E\", \"\\uAAAF\"], \"\\uAAB1\", [\"\\uAAB5\", \"\\uAAB6\"], [\"\\uAAB9\", \"\\uAABD\"], \"\\uAAC0\", \"\\uAAC2\", [\"\\uAADB\", \"\\uAADC\"], [\"\\uAAE0\", \"\\uAAEA\"], \"\\uAAF2\", [\"\\uAB01\", \"\\uAB06\"], [\"\\uAB09\", \"\\uAB0E\"], [\"\\uAB11\", \"\\uAB16\"], [\"\\uAB20\", \"\\uAB26\"], [\"\\uAB28\", \"\\uAB2E\"], [\"\\uABC0\", \"\\uABE2\"], [\"\\uAC00\", \"\\uD7A3\"], [\"\\uD7B0\", \"\\uD7C6\"], [\"\\uD7CB\", \"\\uD7FB\"], [\"\\uF900\", \"\\uFA6D\"], [\"\\uFA70\", \"\\uFAD9\"], \"\\uFB1D\", [\"\\uFB1F\", \"\\uFB28\"], [\"\\uFB2A\", \"\\uFB36\"], [\"\\uFB38\", \"\\uFB3C\"], \"\\uFB3E\", [\"\\uFB40\", \"\\uFB41\"], [\"\\uFB43\", \"\\uFB44\"], [\"\\uFB46\", \"\\uFBB1\"], [\"\\uFBD3\", \"\\uFD3D\"], [\"\\uFD50\", \"\\uFD8F\"], [\"\\uFD92\", \"\\uFDC7\"], [\"\\uFDF0\", \"\\uFDFB\"], [\"\\uFE70\", \"\\uFE74\"], [\"\\uFE76\", \"\\uFEFC\"], [\"\\uFF66\", \"\\uFF6F\"], [\"\\uFF71\", \"\\uFF9D\"], [\"\\uFFA0\", \"\\uFFBE\"], [\"\\uFFC2\", \"\\uFFC7\"], [\"\\uFFCA\", \"\\uFFCF\"], [\"\\uFFD2\", \"\\uFFD7\"], [\"\\uFFDA\", \"\\uFFDC\"]], false, false);\n  var peg$e65 = peg$classExpectation([\"\\u01C5\", \"\\u01C8\", \"\\u01CB\", \"\\u01F2\", [\"\\u1F88\", \"\\u1F8F\"], [\"\\u1F98\", \"\\u1F9F\"], [\"\\u1FA8\", \"\\u1FAF\"], \"\\u1FBC\", \"\\u1FCC\", \"\\u1FFC\"], false, false);\n  var peg$e66 = peg$classExpectation([[\"A\", \"Z\"], [\"\\xC0\", \"\\xD6\"], [\"\\xD8\", \"\\xDE\"], \"\\u0100\", \"\\u0102\", \"\\u0104\", \"\\u0106\", \"\\u0108\", \"\\u010A\", \"\\u010C\", \"\\u010E\", \"\\u0110\", \"\\u0112\", \"\\u0114\", \"\\u0116\", \"\\u0118\", \"\\u011A\", \"\\u011C\", \"\\u011E\", \"\\u0120\", \"\\u0122\", \"\\u0124\", \"\\u0126\", \"\\u0128\", \"\\u012A\", \"\\u012C\", \"\\u012E\", \"\\u0130\", \"\\u0132\", \"\\u0134\", \"\\u0136\", \"\\u0139\", \"\\u013B\", \"\\u013D\", \"\\u013F\", \"\\u0141\", \"\\u0143\", \"\\u0145\", \"\\u0147\", \"\\u014A\", \"\\u014C\", \"\\u014E\", \"\\u0150\", \"\\u0152\", \"\\u0154\", \"\\u0156\", \"\\u0158\", \"\\u015A\", \"\\u015C\", \"\\u015E\", \"\\u0160\", \"\\u0162\", \"\\u0164\", \"\\u0166\", \"\\u0168\", \"\\u016A\", \"\\u016C\", \"\\u016E\", \"\\u0170\", \"\\u0172\", \"\\u0174\", \"\\u0176\", [\"\\u0178\", \"\\u0179\"], \"\\u017B\", \"\\u017D\", [\"\\u0181\", \"\\u0182\"], \"\\u0184\", [\"\\u0186\", \"\\u0187\"], [\"\\u0189\", \"\\u018B\"], [\"\\u018E\", \"\\u0191\"], [\"\\u0193\", \"\\u0194\"], [\"\\u0196\", \"\\u0198\"], [\"\\u019C\", \"\\u019D\"], [\"\\u019F\", \"\\u01A0\"], \"\\u01A2\", \"\\u01A4\", [\"\\u01A6\", \"\\u01A7\"], \"\\u01A9\", \"\\u01AC\", [\"\\u01AE\", \"\\u01AF\"], [\"\\u01B1\", \"\\u01B3\"], \"\\u01B5\", [\"\\u01B7\", \"\\u01B8\"], \"\\u01BC\", \"\\u01C4\", \"\\u01C7\", \"\\u01CA\", \"\\u01CD\", \"\\u01CF\", \"\\u01D1\", \"\\u01D3\", \"\\u01D5\", \"\\u01D7\", \"\\u01D9\", \"\\u01DB\", \"\\u01DE\", \"\\u01E0\", \"\\u01E2\", \"\\u01E4\", \"\\u01E6\", \"\\u01E8\", \"\\u01EA\", \"\\u01EC\", \"\\u01EE\", \"\\u01F1\", \"\\u01F4\", [\"\\u01F6\", \"\\u01F8\"], \"\\u01FA\", \"\\u01FC\", \"\\u01FE\", \"\\u0200\", \"\\u0202\", \"\\u0204\", \"\\u0206\", \"\\u0208\", \"\\u020A\", \"\\u020C\", \"\\u020E\", \"\\u0210\", \"\\u0212\", \"\\u0214\", \"\\u0216\", \"\\u0218\", \"\\u021A\", \"\\u021C\", \"\\u021E\", \"\\u0220\", \"\\u0222\", \"\\u0224\", \"\\u0226\", \"\\u0228\", \"\\u022A\", \"\\u022C\", \"\\u022E\", \"\\u0230\", \"\\u0232\", [\"\\u023A\", \"\\u023B\"], [\"\\u023D\", \"\\u023E\"], \"\\u0241\", [\"\\u0243\", \"\\u0246\"], \"\\u0248\", \"\\u024A\", \"\\u024C\", \"\\u024E\", \"\\u0370\", \"\\u0372\", \"\\u0376\", \"\\u037F\", \"\\u0386\", [\"\\u0388\", \"\\u038A\"], \"\\u038C\", [\"\\u038E\", \"\\u038F\"], [\"\\u0391\", \"\\u03A1\"], [\"\\u03A3\", \"\\u03AB\"], \"\\u03CF\", [\"\\u03D2\", \"\\u03D4\"], \"\\u03D8\", \"\\u03DA\", \"\\u03DC\", \"\\u03DE\", \"\\u03E0\", \"\\u03E2\", \"\\u03E4\", \"\\u03E6\", \"\\u03E8\", \"\\u03EA\", \"\\u03EC\", \"\\u03EE\", \"\\u03F4\", \"\\u03F7\", [\"\\u03F9\", \"\\u03FA\"], [\"\\u03FD\", \"\\u042F\"], \"\\u0460\", \"\\u0462\", \"\\u0464\", \"\\u0466\", \"\\u0468\", \"\\u046A\", \"\\u046C\", \"\\u046E\", \"\\u0470\", \"\\u0472\", \"\\u0474\", \"\\u0476\", \"\\u0478\", \"\\u047A\", \"\\u047C\", \"\\u047E\", \"\\u0480\", \"\\u048A\", \"\\u048C\", \"\\u048E\", \"\\u0490\", \"\\u0492\", \"\\u0494\", \"\\u0496\", \"\\u0498\", \"\\u049A\", \"\\u049C\", \"\\u049E\", \"\\u04A0\", \"\\u04A2\", \"\\u04A4\", \"\\u04A6\", \"\\u04A8\", \"\\u04AA\", \"\\u04AC\", \"\\u04AE\", \"\\u04B0\", \"\\u04B2\", \"\\u04B4\", \"\\u04B6\", \"\\u04B8\", \"\\u04BA\", \"\\u04BC\", \"\\u04BE\", [\"\\u04C0\", \"\\u04C1\"], \"\\u04C3\", \"\\u04C5\", \"\\u04C7\", \"\\u04C9\", \"\\u04CB\", \"\\u04CD\", \"\\u04D0\", \"\\u04D2\", \"\\u04D4\", \"\\u04D6\", \"\\u04D8\", \"\\u04DA\", \"\\u04DC\", \"\\u04DE\", \"\\u04E0\", \"\\u04E2\", \"\\u04E4\", \"\\u04E6\", \"\\u04E8\", \"\\u04EA\", \"\\u04EC\", \"\\u04EE\", \"\\u04F0\", \"\\u04F2\", \"\\u04F4\", \"\\u04F6\", \"\\u04F8\", \"\\u04FA\", \"\\u04FC\", \"\\u04FE\", \"\\u0500\", \"\\u0502\", \"\\u0504\", \"\\u0506\", \"\\u0508\", \"\\u050A\", \"\\u050C\", \"\\u050E\", \"\\u0510\", \"\\u0512\", \"\\u0514\", \"\\u0516\", \"\\u0518\", \"\\u051A\", \"\\u051C\", \"\\u051E\", \"\\u0520\", \"\\u0522\", \"\\u0524\", \"\\u0526\", \"\\u0528\", \"\\u052A\", \"\\u052C\", \"\\u052E\", [\"\\u0531\", \"\\u0556\"], [\"\\u10A0\", \"\\u10C5\"], \"\\u10C7\", \"\\u10CD\", [\"\\u13A0\", \"\\u13F5\"], \"\\u1E00\", \"\\u1E02\", \"\\u1E04\", \"\\u1E06\", \"\\u1E08\", \"\\u1E0A\", \"\\u1E0C\", \"\\u1E0E\", \"\\u1E10\", \"\\u1E12\", \"\\u1E14\", \"\\u1E16\", \"\\u1E18\", \"\\u1E1A\", \"\\u1E1C\", \"\\u1E1E\", \"\\u1E20\", \"\\u1E22\", \"\\u1E24\", \"\\u1E26\", \"\\u1E28\", \"\\u1E2A\", \"\\u1E2C\", \"\\u1E2E\", \"\\u1E30\", \"\\u1E32\", \"\\u1E34\", \"\\u1E36\", \"\\u1E38\", \"\\u1E3A\", \"\\u1E3C\", \"\\u1E3E\", \"\\u1E40\", \"\\u1E42\", \"\\u1E44\", \"\\u1E46\", \"\\u1E48\", \"\\u1E4A\", \"\\u1E4C\", \"\\u1E4E\", \"\\u1E50\", \"\\u1E52\", \"\\u1E54\", \"\\u1E56\", \"\\u1E58\", \"\\u1E5A\", \"\\u1E5C\", \"\\u1E5E\", \"\\u1E60\", \"\\u1E62\", \"\\u1E64\", \"\\u1E66\", \"\\u1E68\", \"\\u1E6A\", \"\\u1E6C\", \"\\u1E6E\", \"\\u1E70\", \"\\u1E72\", \"\\u1E74\", \"\\u1E76\", \"\\u1E78\", \"\\u1E7A\", \"\\u1E7C\", \"\\u1E7E\", \"\\u1E80\", \"\\u1E82\", \"\\u1E84\", \"\\u1E86\", \"\\u1E88\", \"\\u1E8A\", \"\\u1E8C\", \"\\u1E8E\", \"\\u1E90\", \"\\u1E92\", \"\\u1E94\", \"\\u1E9E\", \"\\u1EA0\", \"\\u1EA2\", \"\\u1EA4\", \"\\u1EA6\", \"\\u1EA8\", \"\\u1EAA\", \"\\u1EAC\", \"\\u1EAE\", \"\\u1EB0\", \"\\u1EB2\", \"\\u1EB4\", \"\\u1EB6\", \"\\u1EB8\", \"\\u1EBA\", \"\\u1EBC\", \"\\u1EBE\", \"\\u1EC0\", \"\\u1EC2\", \"\\u1EC4\", \"\\u1EC6\", \"\\u1EC8\", \"\\u1ECA\", \"\\u1ECC\", \"\\u1ECE\", \"\\u1ED0\", \"\\u1ED2\", \"\\u1ED4\", \"\\u1ED6\", \"\\u1ED8\", \"\\u1EDA\", \"\\u1EDC\", \"\\u1EDE\", \"\\u1EE0\", \"\\u1EE2\", \"\\u1EE4\", \"\\u1EE6\", \"\\u1EE8\", \"\\u1EEA\", \"\\u1EEC\", \"\\u1EEE\", \"\\u1EF0\", \"\\u1EF2\", \"\\u1EF4\", \"\\u1EF6\", \"\\u1EF8\", \"\\u1EFA\", \"\\u1EFC\", \"\\u1EFE\", [\"\\u1F08\", \"\\u1F0F\"], [\"\\u1F18\", \"\\u1F1D\"], [\"\\u1F28\", \"\\u1F2F\"], [\"\\u1F38\", \"\\u1F3F\"], [\"\\u1F48\", \"\\u1F4D\"], \"\\u1F59\", \"\\u1F5B\", \"\\u1F5D\", \"\\u1F5F\", [\"\\u1F68\", \"\\u1F6F\"], [\"\\u1FB8\", \"\\u1FBB\"], [\"\\u1FC8\", \"\\u1FCB\"], [\"\\u1FD8\", \"\\u1FDB\"], [\"\\u1FE8\", \"\\u1FEC\"], [\"\\u1FF8\", \"\\u1FFB\"], \"\\u2102\", \"\\u2107\", [\"\\u210B\", \"\\u210D\"], [\"\\u2110\", \"\\u2112\"], \"\\u2115\", [\"\\u2119\", \"\\u211D\"], \"\\u2124\", \"\\u2126\", \"\\u2128\", [\"\\u212A\", \"\\u212D\"], [\"\\u2130\", \"\\u2133\"], [\"\\u213E\", \"\\u213F\"], \"\\u2145\", \"\\u2183\", [\"\\u2C00\", \"\\u2C2E\"], \"\\u2C60\", [\"\\u2C62\", \"\\u2C64\"], \"\\u2C67\", \"\\u2C69\", \"\\u2C6B\", [\"\\u2C6D\", \"\\u2C70\"], \"\\u2C72\", \"\\u2C75\", [\"\\u2C7E\", \"\\u2C80\"], \"\\u2C82\", \"\\u2C84\", \"\\u2C86\", \"\\u2C88\", \"\\u2C8A\", \"\\u2C8C\", \"\\u2C8E\", \"\\u2C90\", \"\\u2C92\", \"\\u2C94\", \"\\u2C96\", \"\\u2C98\", \"\\u2C9A\", \"\\u2C9C\", \"\\u2C9E\", \"\\u2CA0\", \"\\u2CA2\", \"\\u2CA4\", \"\\u2CA6\", \"\\u2CA8\", \"\\u2CAA\", \"\\u2CAC\", \"\\u2CAE\", \"\\u2CB0\", \"\\u2CB2\", \"\\u2CB4\", \"\\u2CB6\", \"\\u2CB8\", \"\\u2CBA\", \"\\u2CBC\", \"\\u2CBE\", \"\\u2CC0\", \"\\u2CC2\", \"\\u2CC4\", \"\\u2CC6\", \"\\u2CC8\", \"\\u2CCA\", \"\\u2CCC\", \"\\u2CCE\", \"\\u2CD0\", \"\\u2CD2\", \"\\u2CD4\", \"\\u2CD6\", \"\\u2CD8\", \"\\u2CDA\", \"\\u2CDC\", \"\\u2CDE\", \"\\u2CE0\", \"\\u2CE2\", \"\\u2CEB\", \"\\u2CED\", \"\\u2CF2\", \"\\uA640\", \"\\uA642\", \"\\uA644\", \"\\uA646\", \"\\uA648\", \"\\uA64A\", \"\\uA64C\", \"\\uA64E\", \"\\uA650\", \"\\uA652\", \"\\uA654\", \"\\uA656\", \"\\uA658\", \"\\uA65A\", \"\\uA65C\", \"\\uA65E\", \"\\uA660\", \"\\uA662\", \"\\uA664\", \"\\uA666\", \"\\uA668\", \"\\uA66A\", \"\\uA66C\", \"\\uA680\", \"\\uA682\", \"\\uA684\", \"\\uA686\", \"\\uA688\", \"\\uA68A\", \"\\uA68C\", \"\\uA68E\", \"\\uA690\", \"\\uA692\", \"\\uA694\", \"\\uA696\", \"\\uA698\", \"\\uA69A\", \"\\uA722\", \"\\uA724\", \"\\uA726\", \"\\uA728\", \"\\uA72A\", \"\\uA72C\", \"\\uA72E\", \"\\uA732\", \"\\uA734\", \"\\uA736\", \"\\uA738\", \"\\uA73A\", \"\\uA73C\", \"\\uA73E\", \"\\uA740\", \"\\uA742\", \"\\uA744\", \"\\uA746\", \"\\uA748\", \"\\uA74A\", \"\\uA74C\", \"\\uA74E\", \"\\uA750\", \"\\uA752\", \"\\uA754\", \"\\uA756\", \"\\uA758\", \"\\uA75A\", \"\\uA75C\", \"\\uA75E\", \"\\uA760\", \"\\uA762\", \"\\uA764\", \"\\uA766\", \"\\uA768\", \"\\uA76A\", \"\\uA76C\", \"\\uA76E\", \"\\uA779\", \"\\uA77B\", [\"\\uA77D\", \"\\uA77E\"], \"\\uA780\", \"\\uA782\", \"\\uA784\", \"\\uA786\", \"\\uA78B\", \"\\uA78D\", \"\\uA790\", \"\\uA792\", \"\\uA796\", \"\\uA798\", \"\\uA79A\", \"\\uA79C\", \"\\uA79E\", \"\\uA7A0\", \"\\uA7A2\", \"\\uA7A4\", \"\\uA7A6\", \"\\uA7A8\", [\"\\uA7AA\", \"\\uA7AD\"], [\"\\uA7B0\", \"\\uA7B4\"], \"\\uA7B6\", [\"\\uFF21\", \"\\uFF3A\"]], false, false);\n  var peg$e67 = peg$classExpectation([\"\\u0903\", \"\\u093B\", [\"\\u093E\", \"\\u0940\"], [\"\\u0949\", \"\\u094C\"], [\"\\u094E\", \"\\u094F\"], [\"\\u0982\", \"\\u0983\"], [\"\\u09BE\", \"\\u09C0\"], [\"\\u09C7\", \"\\u09C8\"], [\"\\u09CB\", \"\\u09CC\"], \"\\u09D7\", \"\\u0A03\", [\"\\u0A3E\", \"\\u0A40\"], \"\\u0A83\", [\"\\u0ABE\", \"\\u0AC0\"], \"\\u0AC9\", [\"\\u0ACB\", \"\\u0ACC\"], [\"\\u0B02\", \"\\u0B03\"], \"\\u0B3E\", \"\\u0B40\", [\"\\u0B47\", \"\\u0B48\"], [\"\\u0B4B\", \"\\u0B4C\"], \"\\u0B57\", [\"\\u0BBE\", \"\\u0BBF\"], [\"\\u0BC1\", \"\\u0BC2\"], [\"\\u0BC6\", \"\\u0BC8\"], [\"\\u0BCA\", \"\\u0BCC\"], \"\\u0BD7\", [\"\\u0C01\", \"\\u0C03\"], [\"\\u0C41\", \"\\u0C44\"], [\"\\u0C82\", \"\\u0C83\"], \"\\u0CBE\", [\"\\u0CC0\", \"\\u0CC4\"], [\"\\u0CC7\", \"\\u0CC8\"], [\"\\u0CCA\", \"\\u0CCB\"], [\"\\u0CD5\", \"\\u0CD6\"], [\"\\u0D02\", \"\\u0D03\"], [\"\\u0D3E\", \"\\u0D40\"], [\"\\u0D46\", \"\\u0D48\"], [\"\\u0D4A\", \"\\u0D4C\"], \"\\u0D57\", [\"\\u0D82\", \"\\u0D83\"], [\"\\u0DCF\", \"\\u0DD1\"], [\"\\u0DD8\", \"\\u0DDF\"], [\"\\u0DF2\", \"\\u0DF3\"], [\"\\u0F3E\", \"\\u0F3F\"], \"\\u0F7F\", [\"\\u102B\", \"\\u102C\"], \"\\u1031\", \"\\u1038\", [\"\\u103B\", \"\\u103C\"], [\"\\u1056\", \"\\u1057\"], [\"\\u1062\", \"\\u1064\"], [\"\\u1067\", \"\\u106D\"], [\"\\u1083\", \"\\u1084\"], [\"\\u1087\", \"\\u108C\"], \"\\u108F\", [\"\\u109A\", \"\\u109C\"], \"\\u17B6\", [\"\\u17BE\", \"\\u17C5\"], [\"\\u17C7\", \"\\u17C8\"], [\"\\u1923\", \"\\u1926\"], [\"\\u1929\", \"\\u192B\"], [\"\\u1930\", \"\\u1931\"], [\"\\u1933\", \"\\u1938\"], [\"\\u1A19\", \"\\u1A1A\"], \"\\u1A55\", \"\\u1A57\", \"\\u1A61\", [\"\\u1A63\", \"\\u1A64\"], [\"\\u1A6D\", \"\\u1A72\"], \"\\u1B04\", \"\\u1B35\", \"\\u1B3B\", [\"\\u1B3D\", \"\\u1B41\"], [\"\\u1B43\", \"\\u1B44\"], \"\\u1B82\", \"\\u1BA1\", [\"\\u1BA6\", \"\\u1BA7\"], \"\\u1BAA\", \"\\u1BE7\", [\"\\u1BEA\", \"\\u1BEC\"], \"\\u1BEE\", [\"\\u1BF2\", \"\\u1BF3\"], [\"\\u1C24\", \"\\u1C2B\"], [\"\\u1C34\", \"\\u1C35\"], \"\\u1CE1\", [\"\\u1CF2\", \"\\u1CF3\"], [\"\\u302E\", \"\\u302F\"], [\"\\uA823\", \"\\uA824\"], \"\\uA827\", [\"\\uA880\", \"\\uA881\"], [\"\\uA8B4\", \"\\uA8C3\"], [\"\\uA952\", \"\\uA953\"], \"\\uA983\", [\"\\uA9B4\", \"\\uA9B5\"], [\"\\uA9BA\", \"\\uA9BB\"], [\"\\uA9BD\", \"\\uA9C0\"], [\"\\uAA2F\", \"\\uAA30\"], [\"\\uAA33\", \"\\uAA34\"], \"\\uAA4D\", \"\\uAA7B\", \"\\uAA7D\", \"\\uAAEB\", [\"\\uAAEE\", \"\\uAAEF\"], \"\\uAAF5\", [\"\\uABE3\", \"\\uABE4\"], [\"\\uABE6\", \"\\uABE7\"], [\"\\uABE9\", \"\\uABEA\"], \"\\uABEC\"], false, false);\n  var peg$e68 = peg$classExpectation([[\"\\u0300\", \"\\u036F\"], [\"\\u0483\", \"\\u0487\"], [\"\\u0591\", \"\\u05BD\"], \"\\u05BF\", [\"\\u05C1\", \"\\u05C2\"], [\"\\u05C4\", \"\\u05C5\"], \"\\u05C7\", [\"\\u0610\", \"\\u061A\"], [\"\\u064B\", \"\\u065F\"], \"\\u0670\", [\"\\u06D6\", \"\\u06DC\"], [\"\\u06DF\", \"\\u06E4\"], [\"\\u06E7\", \"\\u06E8\"], [\"\\u06EA\", \"\\u06ED\"], \"\\u0711\", [\"\\u0730\", \"\\u074A\"], [\"\\u07A6\", \"\\u07B0\"], [\"\\u07EB\", \"\\u07F3\"], [\"\\u0816\", \"\\u0819\"], [\"\\u081B\", \"\\u0823\"], [\"\\u0825\", \"\\u0827\"], [\"\\u0829\", \"\\u082D\"], [\"\\u0859\", \"\\u085B\"], [\"\\u08E3\", \"\\u0902\"], \"\\u093A\", \"\\u093C\", [\"\\u0941\", \"\\u0948\"], \"\\u094D\", [\"\\u0951\", \"\\u0957\"], [\"\\u0962\", \"\\u0963\"], \"\\u0981\", \"\\u09BC\", [\"\\u09C1\", \"\\u09C4\"], \"\\u09CD\", [\"\\u09E2\", \"\\u09E3\"], [\"\\u0A01\", \"\\u0A02\"], \"\\u0A3C\", [\"\\u0A41\", \"\\u0A42\"], [\"\\u0A47\", \"\\u0A48\"], [\"\\u0A4B\", \"\\u0A4D\"], \"\\u0A51\", [\"\\u0A70\", \"\\u0A71\"], \"\\u0A75\", [\"\\u0A81\", \"\\u0A82\"], \"\\u0ABC\", [\"\\u0AC1\", \"\\u0AC5\"], [\"\\u0AC7\", \"\\u0AC8\"], \"\\u0ACD\", [\"\\u0AE2\", \"\\u0AE3\"], \"\\u0B01\", \"\\u0B3C\", \"\\u0B3F\", [\"\\u0B41\", \"\\u0B44\"], \"\\u0B4D\", \"\\u0B56\", [\"\\u0B62\", \"\\u0B63\"], \"\\u0B82\", \"\\u0BC0\", \"\\u0BCD\", \"\\u0C00\", [\"\\u0C3E\", \"\\u0C40\"], [\"\\u0C46\", \"\\u0C48\"], [\"\\u0C4A\", \"\\u0C4D\"], [\"\\u0C55\", \"\\u0C56\"], [\"\\u0C62\", \"\\u0C63\"], \"\\u0C81\", \"\\u0CBC\", \"\\u0CBF\", \"\\u0CC6\", [\"\\u0CCC\", \"\\u0CCD\"], [\"\\u0CE2\", \"\\u0CE3\"], \"\\u0D01\", [\"\\u0D41\", \"\\u0D44\"], \"\\u0D4D\", [\"\\u0D62\", \"\\u0D63\"], \"\\u0DCA\", [\"\\u0DD2\", \"\\u0DD4\"], \"\\u0DD6\", \"\\u0E31\", [\"\\u0E34\", \"\\u0E3A\"], [\"\\u0E47\", \"\\u0E4E\"], \"\\u0EB1\", [\"\\u0EB4\", \"\\u0EB9\"], [\"\\u0EBB\", \"\\u0EBC\"], [\"\\u0EC8\", \"\\u0ECD\"], [\"\\u0F18\", \"\\u0F19\"], \"\\u0F35\", \"\\u0F37\", \"\\u0F39\", [\"\\u0F71\", \"\\u0F7E\"], [\"\\u0F80\", \"\\u0F84\"], [\"\\u0F86\", \"\\u0F87\"], [\"\\u0F8D\", \"\\u0F97\"], [\"\\u0F99\", \"\\u0FBC\"], \"\\u0FC6\", [\"\\u102D\", \"\\u1030\"], [\"\\u1032\", \"\\u1037\"], [\"\\u1039\", \"\\u103A\"], [\"\\u103D\", \"\\u103E\"], [\"\\u1058\", \"\\u1059\"], [\"\\u105E\", \"\\u1060\"], [\"\\u1071\", \"\\u1074\"], \"\\u1082\", [\"\\u1085\", \"\\u1086\"], \"\\u108D\", \"\\u109D\", [\"\\u135D\", \"\\u135F\"], [\"\\u1712\", \"\\u1714\"], [\"\\u1732\", \"\\u1734\"], [\"\\u1752\", \"\\u1753\"], [\"\\u1772\", \"\\u1773\"], [\"\\u17B4\", \"\\u17B5\"], [\"\\u17B7\", \"\\u17BD\"], \"\\u17C6\", [\"\\u17C9\", \"\\u17D3\"], \"\\u17DD\", [\"\\u180B\", \"\\u180D\"], \"\\u18A9\", [\"\\u1920\", \"\\u1922\"], [\"\\u1927\", \"\\u1928\"], \"\\u1932\", [\"\\u1939\", \"\\u193B\"], [\"\\u1A17\", \"\\u1A18\"], \"\\u1A1B\", \"\\u1A56\", [\"\\u1A58\", \"\\u1A5E\"], \"\\u1A60\", \"\\u1A62\", [\"\\u1A65\", \"\\u1A6C\"], [\"\\u1A73\", \"\\u1A7C\"], \"\\u1A7F\", [\"\\u1AB0\", \"\\u1ABD\"], [\"\\u1B00\", \"\\u1B03\"], \"\\u1B34\", [\"\\u1B36\", \"\\u1B3A\"], \"\\u1B3C\", \"\\u1B42\", [\"\\u1B6B\", \"\\u1B73\"], [\"\\u1B80\", \"\\u1B81\"], [\"\\u1BA2\", \"\\u1BA5\"], [\"\\u1BA8\", \"\\u1BA9\"], [\"\\u1BAB\", \"\\u1BAD\"], \"\\u1BE6\", [\"\\u1BE8\", \"\\u1BE9\"], \"\\u1BED\", [\"\\u1BEF\", \"\\u1BF1\"], [\"\\u1C2C\", \"\\u1C33\"], [\"\\u1C36\", \"\\u1C37\"], [\"\\u1CD0\", \"\\u1CD2\"], [\"\\u1CD4\", \"\\u1CE0\"], [\"\\u1CE2\", \"\\u1CE8\"], \"\\u1CED\", \"\\u1CF4\", [\"\\u1CF8\", \"\\u1CF9\"], [\"\\u1DC0\", \"\\u1DF5\"], [\"\\u1DFC\", \"\\u1DFF\"], [\"\\u20D0\", \"\\u20DC\"], \"\\u20E1\", [\"\\u20E5\", \"\\u20F0\"], [\"\\u2CEF\", \"\\u2CF1\"], \"\\u2D7F\", [\"\\u2DE0\", \"\\u2DFF\"], [\"\\u302A\", \"\\u302D\"], [\"\\u3099\", \"\\u309A\"], \"\\uA66F\", [\"\\uA674\", \"\\uA67D\"], [\"\\uA69E\", \"\\uA69F\"], [\"\\uA6F0\", \"\\uA6F1\"], \"\\uA802\", \"\\uA806\", \"\\uA80B\", [\"\\uA825\", \"\\uA826\"], \"\\uA8C4\", [\"\\uA8E0\", \"\\uA8F1\"], [\"\\uA926\", \"\\uA92D\"], [\"\\uA947\", \"\\uA951\"], [\"\\uA980\", \"\\uA982\"], \"\\uA9B3\", [\"\\uA9B6\", \"\\uA9B9\"], \"\\uA9BC\", \"\\uA9E5\", [\"\\uAA29\", \"\\uAA2E\"], [\"\\uAA31\", \"\\uAA32\"], [\"\\uAA35\", \"\\uAA36\"], \"\\uAA43\", \"\\uAA4C\", \"\\uAA7C\", \"\\uAAB0\", [\"\\uAAB2\", \"\\uAAB4\"], [\"\\uAAB7\", \"\\uAAB8\"], [\"\\uAABE\", \"\\uAABF\"], \"\\uAAC1\", [\"\\uAAEC\", \"\\uAAED\"], \"\\uAAF6\", \"\\uABE5\", \"\\uABE8\", \"\\uABED\", \"\\uFB1E\", [\"\\uFE00\", \"\\uFE0F\"], [\"\\uFE20\", \"\\uFE2F\"]], false, false);\n  var peg$e69 = peg$classExpectation([[\"0\", \"9\"], [\"\\u0660\", \"\\u0669\"], [\"\\u06F0\", \"\\u06F9\"], [\"\\u07C0\", \"\\u07C9\"], [\"\\u0966\", \"\\u096F\"], [\"\\u09E6\", \"\\u09EF\"], [\"\\u0A66\", \"\\u0A6F\"], [\"\\u0AE6\", \"\\u0AEF\"], [\"\\u0B66\", \"\\u0B6F\"], [\"\\u0BE6\", \"\\u0BEF\"], [\"\\u0C66\", \"\\u0C6F\"], [\"\\u0CE6\", \"\\u0CEF\"], [\"\\u0D66\", \"\\u0D6F\"], [\"\\u0DE6\", \"\\u0DEF\"], [\"\\u0E50\", \"\\u0E59\"], [\"\\u0ED0\", \"\\u0ED9\"], [\"\\u0F20\", \"\\u0F29\"], [\"\\u1040\", \"\\u1049\"], [\"\\u1090\", \"\\u1099\"], [\"\\u17E0\", \"\\u17E9\"], [\"\\u1810\", \"\\u1819\"], [\"\\u1946\", \"\\u194F\"], [\"\\u19D0\", \"\\u19D9\"], [\"\\u1A80\", \"\\u1A89\"], [\"\\u1A90\", \"\\u1A99\"], [\"\\u1B50\", \"\\u1B59\"], [\"\\u1BB0\", \"\\u1BB9\"], [\"\\u1C40\", \"\\u1C49\"], [\"\\u1C50\", \"\\u1C59\"], [\"\\uA620\", \"\\uA629\"], [\"\\uA8D0\", \"\\uA8D9\"], [\"\\uA900\", \"\\uA909\"], [\"\\uA9D0\", \"\\uA9D9\"], [\"\\uA9F0\", \"\\uA9F9\"], [\"\\uAA50\", \"\\uAA59\"], [\"\\uABF0\", \"\\uABF9\"], [\"\\uFF10\", \"\\uFF19\"]], false, false);\n  var peg$e70 = peg$classExpectation([[\"\\u16EE\", \"\\u16F0\"], [\"\\u2160\", \"\\u2182\"], [\"\\u2185\", \"\\u2188\"], \"\\u3007\", [\"\\u3021\", \"\\u3029\"], [\"\\u3038\", \"\\u303A\"], [\"\\uA6E6\", \"\\uA6EF\"]], false, false);\n  var peg$e71 = peg$classExpectation([\"_\", [\"\\u203F\", \"\\u2040\"], \"\\u2054\", [\"\\uFE33\", \"\\uFE34\"], [\"\\uFE4D\", \"\\uFE4F\"], \"\\uFF3F\"], false, false);\n  var peg$e72 = peg$classExpectation([\" \", \"\\xA0\", \"\\u1680\", [\"\\u2000\", \"\\u200A\"], \"\\u202F\", \"\\u205F\", \"\\u3000\"], false, false);\n  var peg$e73 = peg$literalExpectation(\";\", false);\n\n  var peg$f0 = function(topLevelInitializer, initializer, rules) {\n        return {\n          type: \"grammar\",\n          topLevelInitializer,\n          initializer,\n          rules,\n          location: location()\n        };\n      };\n  var peg$f1 = function(code) {\n        return {\n          type: \"top_level_initializer\",\n          code: code[0],\n          codeLocation: code[1],\n          location: location()\n        };\n      };\n  var peg$f2 = function(code) {\n        return {\n          type: \"initializer\",\n          code: code[0],\n          codeLocation: code[1],\n          location: location()\n        };\n      };\n  var peg$f3 = function(name, displayName, expression) {\n        return {\n          type: \"rule\",\n          name: name[0],\n          nameLocation: name[1],\n          expression: displayName !== null\n            ? {\n                type: \"named\",\n                name: displayName,\n                expression,\n                location: location()\n              }\n            : expression,\n          location: location()\n        };\n      };\n  var peg$f4 = function(head, tail) {\n        return tail.length > 0\n          ? {\n              type: \"choice\",\n              alternatives: [head].concat(tail),\n              location: location()\n            }\n          : head;\n      };\n  var peg$f5 = function(expression, code) {\n        return code !== null\n          ? {\n              type: \"action\",\n              expression,\n              code: code[0],\n              codeLocation: code[1],\n              location: location()\n            }\n          : expression;\n      };\n  var peg$f6 = function(head, tail) {\n        return ((tail.length > 0) || (head.type === \"labeled\" && head.pick))\n          ? {\n              type: \"sequence\",\n              elements: [head].concat(tail),\n              location: location()\n            }\n          : head;\n      };\n  var peg$f7 = function(pluck, label, expression) {\n        if (expression.type.startsWith(\"semantic_\")) {\n          error(\"\\\"@\\\" cannot be used on a semantic predicate\", pluck);\n        }\n        return {\n          type: \"labeled\",\n          label: label !== null ? label[0] : null,\n          // Use location of \"@\" if label is unavailable\n          labelLocation: label !== null ? label[1] : pluck,\n          pick: true,\n          expression,\n          location: location()\n        };\n      };\n  var peg$f8 = function(label, expression) {\n        return {\n          type: \"labeled\",\n          label: label[0],\n          labelLocation: label[1],\n          expression,\n          location: location()\n        };\n      };\n  var peg$f9 = function() { return location(); };\n  var peg$f10 = function(label) {\n        if (reservedWords.indexOf(label[0]) >= 0) {\n          error(`Label can't be a reserved word \"${label[0]}\"`, label[1]);\n        }\n\n        return label;\n      };\n  var peg$f11 = function(operator, expression) {\n        return {\n          type: OPS_TO_PREFIXED_TYPES[operator],\n          expression,\n          location: location()\n        };\n      };\n  var peg$f12 = function(expression, operator) {\n        return {\n          type: OPS_TO_SUFFIXED_TYPES[operator],\n          expression,\n          location: location()\n        };\n      };\n  var peg$f13 = function(expression) {\n        // The purpose of the \"group\" AST node is just to isolate label scope. We\n        // don't need to put it around nodes that can't contain any labels or\n        // nodes that already isolate label scope themselves. This leaves us with\n        // \"labeled\" and \"sequence\".\n        return expression.type === \"labeled\" || expression.type === \"sequence\"\n            ? { type: \"group\", expression, location: location() }\n            : expression;\n      };\n  var peg$f14 = function(name) {\n        return { type: \"rule_ref\", name: name[0], location: location() };\n      };\n  var peg$f15 = function(operator, code) {\n        return {\n          type: OPS_TO_SEMANTIC_PREDICATE_TYPES[operator],\n          code: code[0],\n          codeLocation: code[1],\n          location: location()\n        };\n      };\n  var peg$f16 = function(head, tail) {\n        return [head + tail.join(\"\"), location()];\n      };\n  var peg$f17 = function(value, ignoreCase) {\n        return {\n          type: \"literal\",\n          value,\n          ignoreCase: ignoreCase !== null,\n          location: location()\n        };\n      };\n  var peg$f18 = function(chars) { return chars.join(\"\"); };\n  var peg$f19 = function(inverted, parts, ignoreCase) {\n        return {\n          type: \"class\",\n          parts: parts.filter(part => part !== \"\"),\n          inverted: inverted !== null,\n          ignoreCase: ignoreCase !== null,\n          location: location()\n        };\n      };\n  var peg$f20 = function(begin, end) {\n        if (begin.charCodeAt(0) > end.charCodeAt(0)) {\n          error(\n            \"Invalid character range: \" + text() + \".\"\n          );\n        }\n\n        return [begin, end];\n      };\n  var peg$f21 = function() { return \"\"; };\n  var peg$f22 = function() { return \"\\0\"; };\n  var peg$f23 = function() { return \"\\b\"; };\n  var peg$f24 = function() { return \"\\f\"; };\n  var peg$f25 = function() { return \"\\n\"; };\n  var peg$f26 = function() { return \"\\r\"; };\n  var peg$f27 = function() { return \"\\t\"; };\n  var peg$f28 = function() { return \"\\v\"; };\n  var peg$f29 = function(digits) {\n        return String.fromCharCode(parseInt(digits, 16));\n      };\n  var peg$f30 = function() { return { type: \"any\", location: location() }; };\n  var peg$f31 = function(code) { return [code, location()]; };\n\n  var peg$currPos = 0;\n  var peg$savedPos = 0;\n  var peg$posDetailsCache = [{ line: 1, column: 1 }];\n  var peg$maxFailPos = 0;\n  var peg$maxFailExpected = [];\n  var peg$silentFails = 0;\n\n  var peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function offset() {\n    return peg$savedPos;\n  }\n\n  function range() {\n    return {\n      source: peg$source,\n      start: peg$savedPos,\n      end: peg$currPos\n    };\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== undefined\n      ? location\n      : peg$computeLocation(peg$savedPos, peg$currPos);\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos];\n    var p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line: details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos);\n    var endPosDetails = peg$computePosDetails(endPos);\n\n    return {\n      source: peg$source,\n      start: {\n        offset: startPos,\n        line: startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line: endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parseGrammar() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    s1 = peg$parse__();\n    s2 = peg$currPos;\n    s3 = peg$parseTopLevelInitializer();\n    if (s3 !== peg$FAILED) {\n      s4 = peg$parse__();\n      s2 = s3;\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    s3 = peg$currPos;\n    s4 = peg$parseInitializer();\n    if (s4 !== peg$FAILED) {\n      s5 = peg$parse__();\n      s3 = s4;\n    } else {\n      peg$currPos = s3;\n      s3 = peg$FAILED;\n    }\n    if (s3 === peg$FAILED) {\n      s3 = null;\n    }\n    s4 = [];\n    s5 = peg$currPos;\n    s6 = peg$parseRule();\n    if (s6 !== peg$FAILED) {\n      s7 = peg$parse__();\n      s5 = s6;\n    } else {\n      peg$currPos = s5;\n      s5 = peg$FAILED;\n    }\n    if (s5 !== peg$FAILED) {\n      while (s5 !== peg$FAILED) {\n        s4.push(s5);\n        s5 = peg$currPos;\n        s6 = peg$parseRule();\n        if (s6 !== peg$FAILED) {\n          s7 = peg$parse__();\n          s5 = s6;\n        } else {\n          peg$currPos = s5;\n          s5 = peg$FAILED;\n        }\n      }\n    } else {\n      s4 = peg$FAILED;\n    }\n    if (s4 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s0 = peg$f0(s2, s3, s4);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseTopLevelInitializer() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 123) {\n      s1 = peg$c0;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseCodeBlock();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 125) {\n          s3 = peg$c1;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e1); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseEOS();\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f1(s2);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseInitializer() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseCodeBlock();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseEOS();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f2(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseRule() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    s1 = peg$parseIdentifierName();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      s3 = peg$currPos;\n      s4 = peg$parseStringLiteral();\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parse__();\n        s3 = s4;\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      if (input.charCodeAt(peg$currPos) === 61) {\n        s4 = peg$c2;\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e2); }\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parse__();\n        s6 = peg$parseChoiceExpression();\n        if (s6 !== peg$FAILED) {\n          s7 = peg$parseEOS();\n          if (s7 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s0 = peg$f3(s1, s3, s6);\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseChoiceExpression() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    s1 = peg$parseActionExpression();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse__();\n      if (input.charCodeAt(peg$currPos) === 47) {\n        s5 = peg$c3;\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e3); }\n      }\n      if (s5 !== peg$FAILED) {\n        s6 = peg$parse__();\n        s7 = peg$parseActionExpression();\n        if (s7 !== peg$FAILED) {\n          s3 = s7;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parse__();\n        if (input.charCodeAt(peg$currPos) === 47) {\n          s5 = peg$c3;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e3); }\n        }\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parse__();\n          s7 = peg$parseActionExpression();\n          if (s7 !== peg$FAILED) {\n            s3 = s7;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      peg$savedPos = s0;\n      s0 = peg$f4(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseActionExpression() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$parseSequenceExpression();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$parse__();\n      s4 = peg$parseCodeBlock();\n      if (s4 !== peg$FAILED) {\n        s2 = s4;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      peg$savedPos = s0;\n      s0 = peg$f5(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseSequenceExpression() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseLabeledExpression();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parse__();\n      s5 = peg$parseLabeledExpression();\n      if (s5 !== peg$FAILED) {\n        s3 = s5;\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parse__();\n        s5 = peg$parseLabeledExpression();\n        if (s5 !== peg$FAILED) {\n          s3 = s5;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      peg$savedPos = s0;\n      s0 = peg$f6(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseLabeledExpression() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsePluck();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseLabelColon();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      s3 = peg$parsePrefixedExpression();\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f7(s1, s2, s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parseLabelColon();\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parse__();\n        s3 = peg$parsePrefixedExpression();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f8(s1, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsePrefixedExpression();\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsePluck() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 64) {\n      s1 = peg$c4;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e4); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f9();\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseLabelColon() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseIdentifierName();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      if (input.charCodeAt(peg$currPos) === 58) {\n        s3 = peg$c5;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e5); }\n      }\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f10(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsePrefixedExpression() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsePrefixedOperator();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      s3 = peg$parseSuffixedExpression();\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f11(s1, s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseSuffixedExpression();\n    }\n\n    return s0;\n  }\n\n  function peg$parsePrefixedOperator() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 36) {\n      s0 = peg$c6;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e6); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 38) {\n        s0 = peg$c7;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e7); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 33) {\n          s0 = peg$c8;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e8); }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseSuffixedExpression() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsePrimaryExpression();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      s3 = peg$parseSuffixedOperator();\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f12(s1, s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$parsePrimaryExpression();\n    }\n\n    return s0;\n  }\n\n  function peg$parseSuffixedOperator() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 63) {\n      s0 = peg$c9;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e9); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 42) {\n        s0 = peg$c10;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e10); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 43) {\n          s0 = peg$c11;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e11); }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsePrimaryExpression() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$parseLiteralMatcher();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseCharacterClassMatcher();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseAnyMatcher();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseRuleReferenceExpression();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseSemanticPredicateExpression();\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 40) {\n                s1 = peg$c12;\n                peg$currPos++;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e12); }\n              }\n              if (s1 !== peg$FAILED) {\n                s2 = peg$parse__();\n                s3 = peg$parseChoiceExpression();\n                if (s3 !== peg$FAILED) {\n                  s4 = peg$parse__();\n                  if (input.charCodeAt(peg$currPos) === 41) {\n                    s5 = peg$c13;\n                    peg$currPos++;\n                  } else {\n                    s5 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$e13); }\n                  }\n                  if (s5 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s0 = peg$f13(s3);\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseRuleReferenceExpression() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    s1 = peg$parseIdentifierName();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      peg$silentFails++;\n      s3 = peg$currPos;\n      s4 = peg$parse__();\n      s5 = peg$currPos;\n      s6 = peg$parseStringLiteral();\n      if (s6 !== peg$FAILED) {\n        s7 = peg$parse__();\n        s6 = [s6, s7];\n        s5 = s6;\n      } else {\n        peg$currPos = s5;\n        s5 = peg$FAILED;\n      }\n      if (s5 === peg$FAILED) {\n        s5 = null;\n      }\n      if (input.charCodeAt(peg$currPos) === 61) {\n        s6 = peg$c2;\n        peg$currPos++;\n      } else {\n        s6 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e2); }\n      }\n      if (s6 !== peg$FAILED) {\n        s4 = [s4, s5, s6];\n        s3 = s4;\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      peg$silentFails--;\n      if (s3 === peg$FAILED) {\n        s2 = undefined;\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f14(s1);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseSemanticPredicateExpression() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseSemanticPredicateOperator();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parse__();\n      s3 = peg$parseCodeBlock();\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f15(s1, s3);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseSemanticPredicateOperator() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 38) {\n      s0 = peg$c7;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e7); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 33) {\n        s0 = peg$c8;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e8); }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseSourceCharacter() {\n    var s0;\n\n    if (input.length > peg$currPos) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e14); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseWhiteSpace() {\n    var s0, s1;\n\n    peg$silentFails++;\n    if (input.charCodeAt(peg$currPos) === 9) {\n      s0 = peg$c14;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e16); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 11) {\n        s0 = peg$c15;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e17); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 12) {\n          s0 = peg$c16;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e18); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 32) {\n            s0 = peg$c17;\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e19); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 160) {\n              s0 = peg$c18;\n              peg$currPos++;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e20); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 65279) {\n                s0 = peg$c19;\n                peg$currPos++;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e21); }\n              }\n              if (s0 === peg$FAILED) {\n                s0 = peg$parseZs();\n              }\n            }\n          }\n        }\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e15); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseLineTerminator() {\n    var s0;\n\n    if (peg$r0.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e22); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseLineTerminatorSequence() {\n    var s0, s1;\n\n    peg$silentFails++;\n    if (input.charCodeAt(peg$currPos) === 10) {\n      s0 = peg$c20;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e24); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.substr(peg$currPos, 2) === peg$c21) {\n        s0 = peg$c21;\n        peg$currPos += 2;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e25); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 13) {\n          s0 = peg$c22;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e26); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 8232) {\n            s0 = peg$c23;\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e27); }\n          }\n          if (s0 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 8233) {\n              s0 = peg$c24;\n              peg$currPos++;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e28); }\n            }\n          }\n        }\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e23); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseComment() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = peg$parseMultiLineComment();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseSingleLineComment();\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e29); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseMultiLineComment() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 2) === peg$c25) {\n      s1 = peg$c25;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e30); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      if (input.substr(peg$currPos, 2) === peg$c26) {\n        s5 = peg$c26;\n        peg$currPos += 2;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e31); }\n      }\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = undefined;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseSourceCharacter();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        if (input.substr(peg$currPos, 2) === peg$c26) {\n          s5 = peg$c26;\n          peg$currPos += 2;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e31); }\n        }\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = undefined;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseSourceCharacter();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (input.substr(peg$currPos, 2) === peg$c26) {\n        s3 = peg$c26;\n        peg$currPos += 2;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e31); }\n      }\n      if (s3 !== peg$FAILED) {\n        s1 = [s1, s2, s3];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseMultiLineCommentNoLineTerminator() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 2) === peg$c25) {\n      s1 = peg$c25;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e30); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      if (input.substr(peg$currPos, 2) === peg$c26) {\n        s5 = peg$c26;\n        peg$currPos += 2;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e31); }\n      }\n      if (s5 === peg$FAILED) {\n        s5 = peg$parseLineTerminator();\n      }\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = undefined;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseSourceCharacter();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        if (input.substr(peg$currPos, 2) === peg$c26) {\n          s5 = peg$c26;\n          peg$currPos += 2;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e31); }\n        }\n        if (s5 === peg$FAILED) {\n          s5 = peg$parseLineTerminator();\n        }\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = undefined;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseSourceCharacter();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (input.substr(peg$currPos, 2) === peg$c26) {\n        s3 = peg$c26;\n        peg$currPos += 2;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e31); }\n      }\n      if (s3 !== peg$FAILED) {\n        s1 = [s1, s2, s3];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseSingleLineComment() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    if (input.substr(peg$currPos, 2) === peg$c27) {\n      s1 = peg$c27;\n      peg$currPos += 2;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e32); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      s5 = peg$parseLineTerminator();\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = undefined;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseSourceCharacter();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        s5 = peg$parseLineTerminator();\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = undefined;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseSourceCharacter();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      s1 = [s1, s2];\n      s0 = s1;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseIdentifierName() {\n    var s0, s1, s2, s3;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parseIdentifierStart();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parseIdentifierPart();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseIdentifierPart();\n      }\n      peg$savedPos = s0;\n      s0 = peg$f16(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e33); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseIdentifierStart() {\n    var s0, s1, s2;\n\n    s0 = peg$parseUnicodeLetter();\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 36) {\n        s0 = peg$c6;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e6); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 95) {\n          s0 = peg$c28;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e34); }\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 92) {\n            s1 = peg$c29;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e35); }\n          }\n          if (s1 !== peg$FAILED) {\n            s2 = peg$parseUnicodeEscapeSequence();\n            if (s2 !== peg$FAILED) {\n              s0 = s2;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseIdentifierPart() {\n    var s0;\n\n    s0 = peg$parseIdentifierStart();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseUnicodeCombiningMark();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseNd();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsePc();\n          if (s0 === peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 8204) {\n              s0 = peg$c30;\n              peg$currPos++;\n            } else {\n              s0 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e36); }\n            }\n            if (s0 === peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 8205) {\n                s0 = peg$c31;\n                peg$currPos++;\n              } else {\n                s0 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e37); }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseUnicodeLetter() {\n    var s0;\n\n    s0 = peg$parseLu();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseLl();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseLt();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseLm();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parseLo();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parseNl();\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseUnicodeCombiningMark() {\n    var s0;\n\n    s0 = peg$parseMn();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseMc();\n    }\n\n    return s0;\n  }\n\n  function peg$parseLiteralMatcher() {\n    var s0, s1, s2;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parseStringLiteral();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 105) {\n        s2 = peg$c32;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e39); }\n      }\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      peg$savedPos = s0;\n      s0 = peg$f17(s1, s2);\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e38); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseStringLiteral() {\n    var s0, s1, s2, s3;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 34) {\n      s1 = peg$c33;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e41); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parseDoubleStringCharacter();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseDoubleStringCharacter();\n      }\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s3 = peg$c33;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e41); }\n      }\n      if (s3 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f18(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 39) {\n        s1 = peg$c34;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e42); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = [];\n        s3 = peg$parseSingleStringCharacter();\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$parseSingleStringCharacter();\n        }\n        if (input.charCodeAt(peg$currPos) === 39) {\n          s3 = peg$c34;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e42); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f18(s2);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e40); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseDoubleStringCharacter() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$currPos;\n    peg$silentFails++;\n    if (input.charCodeAt(peg$currPos) === 34) {\n      s3 = peg$c33;\n      peg$currPos++;\n    } else {\n      s3 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e41); }\n    }\n    if (s3 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s3 = peg$c29;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e35); }\n      }\n      if (s3 === peg$FAILED) {\n        s3 = peg$parseLineTerminator();\n      }\n    }\n    peg$silentFails--;\n    if (s3 === peg$FAILED) {\n      s2 = undefined;\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseSourceCharacter();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s1 = peg$c29;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e35); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseEscapeSequence();\n        if (s2 !== peg$FAILED) {\n          s0 = s2;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseLineContinuation();\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseSingleStringCharacter() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$currPos;\n    peg$silentFails++;\n    if (input.charCodeAt(peg$currPos) === 39) {\n      s3 = peg$c34;\n      peg$currPos++;\n    } else {\n      s3 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e42); }\n    }\n    if (s3 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s3 = peg$c29;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e35); }\n      }\n      if (s3 === peg$FAILED) {\n        s3 = peg$parseLineTerminator();\n      }\n    }\n    peg$silentFails--;\n    if (s3 === peg$FAILED) {\n      s2 = undefined;\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseSourceCharacter();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s1 = peg$c29;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e35); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseEscapeSequence();\n        if (s2 !== peg$FAILED) {\n          s0 = s2;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseLineContinuation();\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseCharacterClassMatcher() {\n    var s0, s1, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 91) {\n      s1 = peg$c35;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e44); }\n    }\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 94) {\n        s2 = peg$c36;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e45); }\n      }\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      s3 = [];\n      s4 = peg$parseClassCharacterRange();\n      if (s4 === peg$FAILED) {\n        s4 = peg$parseClassCharacter();\n      }\n      while (s4 !== peg$FAILED) {\n        s3.push(s4);\n        s4 = peg$parseClassCharacterRange();\n        if (s4 === peg$FAILED) {\n          s4 = peg$parseClassCharacter();\n        }\n      }\n      if (input.charCodeAt(peg$currPos) === 93) {\n        s4 = peg$c37;\n        peg$currPos++;\n      } else {\n        s4 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e46); }\n      }\n      if (s4 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 105) {\n          s5 = peg$c32;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e39); }\n        }\n        if (s5 === peg$FAILED) {\n          s5 = null;\n        }\n        peg$savedPos = s0;\n        s0 = peg$f19(s2, s3, s5);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e43); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseClassCharacterRange() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseClassCharacter();\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 45) {\n        s2 = peg$c38;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e47); }\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseClassCharacter();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f20(s1, s3);\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseClassCharacter() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$currPos;\n    peg$silentFails++;\n    if (input.charCodeAt(peg$currPos) === 93) {\n      s3 = peg$c37;\n      peg$currPos++;\n    } else {\n      s3 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e46); }\n    }\n    if (s3 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s3 = peg$c29;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e35); }\n      }\n      if (s3 === peg$FAILED) {\n        s3 = peg$parseLineTerminator();\n      }\n    }\n    peg$silentFails--;\n    if (s3 === peg$FAILED) {\n      s2 = undefined;\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseSourceCharacter();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s1 = peg$c29;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e35); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseEscapeSequence();\n        if (s2 !== peg$FAILED) {\n          s0 = s2;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseLineContinuation();\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseLineContinuation() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 92) {\n      s1 = peg$c29;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e35); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseLineTerminatorSequence();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f21();\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseEscapeSequence() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$parseCharacterEscapeSequence();\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 48) {\n        s1 = peg$c39;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e48); }\n      }\n      if (s1 !== peg$FAILED) {\n        s2 = peg$currPos;\n        peg$silentFails++;\n        s3 = peg$parseDecimalDigit();\n        peg$silentFails--;\n        if (s3 === peg$FAILED) {\n          s2 = undefined;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s0 = peg$f22();\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseHexEscapeSequence();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parseUnicodeEscapeSequence();\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseCharacterEscapeSequence() {\n    var s0;\n\n    s0 = peg$parseSingleEscapeCharacter();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseNonEscapeCharacter();\n    }\n\n    return s0;\n  }\n\n  function peg$parseSingleEscapeCharacter() {\n    var s0, s1;\n\n    if (input.charCodeAt(peg$currPos) === 39) {\n      s0 = peg$c34;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e42); }\n    }\n    if (s0 === peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 34) {\n        s0 = peg$c33;\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e41); }\n      }\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 92) {\n          s0 = peg$c29;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e35); }\n        }\n        if (s0 === peg$FAILED) {\n          s0 = peg$currPos;\n          if (input.charCodeAt(peg$currPos) === 98) {\n            s1 = peg$c40;\n            peg$currPos++;\n          } else {\n            s1 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e49); }\n          }\n          if (s1 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$f23();\n          }\n          s0 = s1;\n          if (s0 === peg$FAILED) {\n            s0 = peg$currPos;\n            if (input.charCodeAt(peg$currPos) === 102) {\n              s1 = peg$c41;\n              peg$currPos++;\n            } else {\n              s1 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$e50); }\n            }\n            if (s1 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$f24();\n            }\n            s0 = s1;\n            if (s0 === peg$FAILED) {\n              s0 = peg$currPos;\n              if (input.charCodeAt(peg$currPos) === 110) {\n                s1 = peg$c42;\n                peg$currPos++;\n              } else {\n                s1 = peg$FAILED;\n                if (peg$silentFails === 0) { peg$fail(peg$e51); }\n              }\n              if (s1 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$f25();\n              }\n              s0 = s1;\n              if (s0 === peg$FAILED) {\n                s0 = peg$currPos;\n                if (input.charCodeAt(peg$currPos) === 114) {\n                  s1 = peg$c43;\n                  peg$currPos++;\n                } else {\n                  s1 = peg$FAILED;\n                  if (peg$silentFails === 0) { peg$fail(peg$e52); }\n                }\n                if (s1 !== peg$FAILED) {\n                  peg$savedPos = s0;\n                  s1 = peg$f26();\n                }\n                s0 = s1;\n                if (s0 === peg$FAILED) {\n                  s0 = peg$currPos;\n                  if (input.charCodeAt(peg$currPos) === 116) {\n                    s1 = peg$c44;\n                    peg$currPos++;\n                  } else {\n                    s1 = peg$FAILED;\n                    if (peg$silentFails === 0) { peg$fail(peg$e53); }\n                  }\n                  if (s1 !== peg$FAILED) {\n                    peg$savedPos = s0;\n                    s1 = peg$f27();\n                  }\n                  s0 = s1;\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$currPos;\n                    if (input.charCodeAt(peg$currPos) === 118) {\n                      s1 = peg$c45;\n                      peg$currPos++;\n                    } else {\n                      s1 = peg$FAILED;\n                      if (peg$silentFails === 0) { peg$fail(peg$e54); }\n                    }\n                    if (s1 !== peg$FAILED) {\n                      peg$savedPos = s0;\n                      s1 = peg$f28();\n                    }\n                    s0 = s1;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseNonEscapeCharacter() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$currPos;\n    peg$silentFails++;\n    s3 = peg$parseEscapeCharacter();\n    if (s3 === peg$FAILED) {\n      s3 = peg$parseLineTerminator();\n    }\n    peg$silentFails--;\n    if (s3 === peg$FAILED) {\n      s2 = undefined;\n    } else {\n      peg$currPos = s2;\n      s2 = peg$FAILED;\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseSourceCharacter();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s0 = input.substring(s0, peg$currPos);\n    } else {\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parseEscapeCharacter() {\n    var s0;\n\n    s0 = peg$parseSingleEscapeCharacter();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parseDecimalDigit();\n      if (s0 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 120) {\n          s0 = peg$c46;\n          peg$currPos++;\n        } else {\n          s0 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e55); }\n        }\n        if (s0 === peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 117) {\n            s0 = peg$c47;\n            peg$currPos++;\n          } else {\n            s0 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e56); }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseHexEscapeSequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 120) {\n      s1 = peg$c46;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e55); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      s4 = peg$parseHexDigit();\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseHexDigit();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f29(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseUnicodeEscapeSequence() {\n    var s0, s1, s2, s3, s4, s5, s6, s7;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 117) {\n      s1 = peg$c47;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e56); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$currPos;\n      s4 = peg$parseHexDigit();\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseHexDigit();\n        if (s5 !== peg$FAILED) {\n          s6 = peg$parseHexDigit();\n          if (s6 !== peg$FAILED) {\n            s7 = peg$parseHexDigit();\n            if (s7 !== peg$FAILED) {\n              s4 = [s4, s5, s6, s7];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s0 = peg$f29(s2);\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseDecimalDigit() {\n    var s0;\n\n    if (peg$r1.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e57); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseHexDigit() {\n    var s0;\n\n    if (peg$r2.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e58); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseAnyMatcher() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 46) {\n      s1 = peg$c48;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e59); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$f30();\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseCodeBlock() {\n    var s0, s1, s2, s3;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 123) {\n      s1 = peg$c0;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e0); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseBareCodeBlock();\n      if (input.charCodeAt(peg$currPos) === 125) {\n        s3 = peg$c1;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e1); }\n      }\n      if (s3 !== peg$FAILED) {\n        s0 = s2;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e60); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseBareCodeBlock() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parseCode();\n    peg$savedPos = s0;\n    s1 = peg$f31(s1);\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseCode() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = [];\n    s3 = peg$currPos;\n    s4 = peg$currPos;\n    peg$silentFails++;\n    if (peg$r3.test(input.charAt(peg$currPos))) {\n      s5 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s5 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e61); }\n    }\n    peg$silentFails--;\n    if (s5 === peg$FAILED) {\n      s4 = undefined;\n    } else {\n      peg$currPos = s4;\n      s4 = peg$FAILED;\n    }\n    if (s4 !== peg$FAILED) {\n      s5 = peg$parseSourceCharacter();\n      if (s5 !== peg$FAILED) {\n        s4 = [s4, s5];\n        s3 = s4;\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s3;\n      s3 = peg$FAILED;\n    }\n    if (s3 !== peg$FAILED) {\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$currPos;\n        peg$silentFails++;\n        if (peg$r3.test(input.charAt(peg$currPos))) {\n          s5 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e61); }\n        }\n        peg$silentFails--;\n        if (s5 === peg$FAILED) {\n          s4 = undefined;\n        } else {\n          peg$currPos = s4;\n          s4 = peg$FAILED;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseSourceCharacter();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n    } else {\n      s2 = peg$FAILED;\n    }\n    if (s2 === peg$FAILED) {\n      s2 = peg$currPos;\n      if (input.charCodeAt(peg$currPos) === 123) {\n        s3 = peg$c0;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e0); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parseCode();\n        if (input.charCodeAt(peg$currPos) === 125) {\n          s5 = peg$c1;\n          peg$currPos++;\n        } else {\n          s5 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e1); }\n        }\n        if (s5 !== peg$FAILED) {\n          s3 = [s3, s4, s5];\n          s2 = s3;\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n    }\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$currPos;\n      peg$silentFails++;\n      if (peg$r3.test(input.charAt(peg$currPos))) {\n        s5 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s5 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$e61); }\n      }\n      peg$silentFails--;\n      if (s5 === peg$FAILED) {\n        s4 = undefined;\n      } else {\n        peg$currPos = s4;\n        s4 = peg$FAILED;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseSourceCharacter();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      if (s3 !== peg$FAILED) {\n        while (s3 !== peg$FAILED) {\n          s2.push(s3);\n          s3 = peg$currPos;\n          s4 = peg$currPos;\n          peg$silentFails++;\n          if (peg$r3.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e61); }\n          }\n          peg$silentFails--;\n          if (s5 === peg$FAILED) {\n            s4 = undefined;\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parseSourceCharacter();\n            if (s5 !== peg$FAILED) {\n              s4 = [s4, s5];\n              s3 = s4;\n            } else {\n              peg$currPos = s3;\n              s3 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        }\n      } else {\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = peg$currPos;\n        if (input.charCodeAt(peg$currPos) === 123) {\n          s3 = peg$c0;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$e0); }\n        }\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parseCode();\n          if (input.charCodeAt(peg$currPos) === 125) {\n            s5 = peg$c1;\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$e1); }\n          }\n          if (s5 !== peg$FAILED) {\n            s3 = [s3, s4, s5];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      }\n    }\n    s0 = input.substring(s0, peg$currPos);\n\n    return s0;\n  }\n\n  function peg$parseLl() {\n    var s0;\n\n    if (peg$r4.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e62); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseLm() {\n    var s0;\n\n    if (peg$r5.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e63); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseLo() {\n    var s0;\n\n    if (peg$r6.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e64); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseLt() {\n    var s0;\n\n    if (peg$r7.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e65); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseLu() {\n    var s0;\n\n    if (peg$r8.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e66); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseMc() {\n    var s0;\n\n    if (peg$r9.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e67); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseMn() {\n    var s0;\n\n    if (peg$r10.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e68); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseNd() {\n    var s0;\n\n    if (peg$r11.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e69); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseNl() {\n    var s0;\n\n    if (peg$r12.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e70); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsePc() {\n    var s0;\n\n    if (peg$r13.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e71); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseZs() {\n    var s0;\n\n    if (peg$r14.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e72); }\n    }\n\n    return s0;\n  }\n\n  function peg$parse__() {\n    var s0, s1;\n\n    s0 = [];\n    s1 = peg$parseWhiteSpace();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parseLineTerminatorSequence();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseComment();\n      }\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      s1 = peg$parseWhiteSpace();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseLineTerminatorSequence();\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseComment();\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parse_() {\n    var s0, s1;\n\n    s0 = [];\n    s1 = peg$parseWhiteSpace();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parseMultiLineCommentNoLineTerminator();\n    }\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      s1 = peg$parseWhiteSpace();\n      if (s1 === peg$FAILED) {\n        s1 = peg$parseMultiLineCommentNoLineTerminator();\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseEOS() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse__();\n    if (input.charCodeAt(peg$currPos) === 59) {\n      s2 = peg$c49;\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e73); }\n    }\n    if (s2 !== peg$FAILED) {\n      s1 = [s1, s2];\n      s0 = s1;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$parse_();\n      s2 = peg$parseSingleLineComment();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      s3 = peg$parseLineTerminatorSequence();\n      if (s3 !== peg$FAILED) {\n        s1 = [s1, s2, s3];\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parse__();\n        s2 = peg$parseEOF();\n        if (s2 !== peg$FAILED) {\n          s1 = [s1, s2];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parseEOF() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    peg$silentFails++;\n    if (input.length > peg$currPos) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$e14); }\n    }\n    peg$silentFails--;\n    if (s1 === peg$FAILED) {\n      s0 = undefined;\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n\n    // Cannot use Set here because of native IE support.\n    const reservedWords = options.reservedWords || [];\n\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse: peg$parse\n};\n\n\n//# sourceURL=webpack://maap-input-parser/./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/parser.js?");

/***/ }),

/***/ "./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/peg.js":
/*!*********************************************************************************************!*\
  !*** ./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/peg.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nconst GrammarError = __webpack_require__(/*! ./grammar-error */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/grammar-error.js\");\nconst compiler = __webpack_require__(/*! ./compiler */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/compiler/index.js\");\nconst parser = __webpack_require__(/*! ./parser */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/parser.js\");\nconst VERSION = __webpack_require__(/*! ./version */ \"./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/version.js\");\n\nconst RESERVED_WORDS = [\n  // Reserved keywords as of ECMAScript 2015\n  \"break\",\n  \"case\",\n  \"catch\",\n  \"class\",\n  \"const\",\n  \"continue\",\n  \"debugger\",\n  \"default\",\n  \"delete\",\n  \"do\",\n  \"else\",\n  \"export\",\n  \"extends\",\n  \"finally\",\n  \"for\",\n  \"function\",\n  \"if\",\n  \"import\",\n  \"in\",\n  \"instanceof\",\n  \"new\",\n  \"return\",\n  \"super\",\n  \"switch\",\n  \"this\",\n  \"throw\",\n  \"try\",\n  \"typeof\",\n  \"var\",\n  \"void\",\n  \"while\",\n  \"with\",\n  // \"yield\", // encountered twice on the web page\n\n  // Special constants\n  \"null\",\n  \"true\",\n  \"false\",\n\n  // These are always reserved:\n  \"enum\",\n\n  // The following are only reserved when they are found in strict mode code\n  // Peggy generates code in strictly mode, so it applicable to it\n  \"implements\",\n  \"interface\",\n  \"let\",\n  \"package\",\n  \"private\",\n  \"protected\",\n  \"public\",\n  \"static\",\n  \"yield\",\n\n  // The following are only reserved when they are found in module code:\n  \"await\"\n];\n\nconst peg = {\n  // Peggy version (filled in by /tools/release).\n  VERSION,\n  /**\n   * Default list of reserved words. Contains list of currently and future\n   * JavaScript (ECMAScript 2015) reserved words.\n   *\n   * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Lexical_grammar#reserved_keywords_as_of_ecmascript_2015\n   */\n  RESERVED_WORDS,\n  GrammarError,\n  parser,\n  compiler,\n\n  // Generates a parser from a specified grammar and returns it.\n  //\n  // The grammar must be a string in the format described by the meta-grammar in\n  // the parser.pegjs file.\n  //\n  // Throws |peg.parser.SyntaxError| if the grammar contains a syntax error or\n  // |peg.GrammarError| if it contains a semantic error. Note that not all\n  // errors are detected during the generation and some may protrude to the\n  // generated parser and cause its malfunction.\n  generate(grammar, options) {\n    options = options !== undefined ? options : {};\n\n    function copyPasses(passes) {\n      const converted = {};\n      Object.keys(passes).forEach(stage => {\n        converted[stage] = passes[stage].slice();\n      });\n\n      return converted;\n    }\n\n    const plugins = \"plugins\" in options ? options.plugins : [];\n    const config = {\n      parser: peg.parser,\n      passes: copyPasses(peg.compiler.passes),\n      reservedWords: peg.RESERVED_WORDS.slice(),\n    };\n\n    plugins.forEach(p => { p.use(config, options); });\n\n    return peg.compiler.compile(\n      config.parser.parse(grammar, {\n        grammarSource: options.grammarSource,\n        reservedWords: config.reservedWords,\n      }),\n      config.passes,\n      options\n    );\n  }\n};\n\nmodule.exports = peg;\n\n\n//# sourceURL=webpack://maap-input-parser/./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/peg.js?");

/***/ }),

/***/ "./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/version.js":
/*!*************************************************************************************************!*\
  !*** ./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/version.js ***!
  \*************************************************************************************************/
/***/ ((module) => {

eval("\n// This file is generated.\n// Do not edit it!  Your work will be overwritten.\n//\n// Instead, please look at ./tools/set_version.js\n\n\n\nmodule.exports = \"1.2.0\";\n\n\n//# sourceURL=webpack://maap-input-parser/./.yarn/cache/peggy-npm-1.2.0-dcccbe8690-658c985df8.zip/node_modules/peggy/lib/version.js?");

/***/ }),

/***/ "./src/maapInpParser.pegjs":
/*!*********************************!*\
  !*** ./src/maapInpParser.pegjs ***!
  \*********************************/
/***/ ((module) => {

eval("module.exports = \"{\\r\\n\\tfunction extractList(list, index) {\\r\\n    \\treturn list.map(i => i[index]);\\r\\n    }\\r\\n}\\r\\n\\r\\nStart = __ program:Program __ {\\r\\n\\treturn program;\\r\\n}\\r\\n\\r\\n/* Lexical Grammar */\\r\\nSourceCharacter = .\\r\\nFreeCharacter = !LineTerminator SourceCharacter\\r\\nWhiteSpace = \\\"\\\\t\\\" / \\\"\\\\v\\\" / \\\"\\\\f\\\" / \\\" \\\" / \\\"\\\\u00A0\\\" / \\\"\\\\uFEFF\\\" / Zs\\r\\nLineTerminator = [\\\\n\\\\r\\\\u2028\\\\u2029]\\r\\nLineTerminatorSequence = \\\"\\\\n\\\" / \\\"\\\\r\\\\n\\\" / \\\"\\\\r\\\" / \\\"\\\\u2028\\\" / \\\"\\\\u2029\\\"\\r\\nComment = SingleLineComment\\r\\nCommentIndicator = \\\"//\\\" / \\\"!\\\" / \\\"C\\\" / \\\"**\\\"\\r\\nSingleLineComment = CommentIndicator v:FreeCharacter*\\r\\nIdentifierStart = UnicodeLetter / \\\"$\\\" / \\\"_\\\" / \\\"\\\\\\\\\\\"\\r\\nUnicodeLetter = Lu / Ll / Lt / Lm / Lo / Nl\\r\\nLiteral = BooleanLiteral / NumericLiteral / TimerLiteral\\r\\nUnits = first:[a-zA-Z0-9]+ rest:((\\\"**\\\" / \\\"/\\\") Units)? {\\r\\n\\tlet units = first.join('');\\r\\n    if (rest) {\\r\\n    \\tunits += rest[0] + rest[1];\\r\\n    }\\r\\n    return units;\\r\\n}\\r\\nNumericLiteral = literal:DecimalLiteral !(IdentifierStart / DecimalDigit) units:(_ Units)? {\\r\\n\\treturn {\\r\\n    \\ttype: \\\"number\\\",\\r\\n        value: literal,\\r\\n        units: (units || [])[1],\\r\\n    }\\r\\n}\\r\\nDecimalLiteral = DecimalIntegerLiteral \\\".\\\" DecimalDigit* ExponentPart? {\\r\\n\\treturn parseFloat(text());\\r\\n}\\r\\n\\t/ \\\".\\\" DecimalDigit+ ExponentPart? {\\r\\n    return parseFloat(text());\\r\\n}\\r\\n\\t/ DecimalIntegerLiteral ExponentPart? {\\r\\n    return parseFloat(text());\\r\\n}\\r\\nDecimalIntegerLiteral = \\\"0\\\" / NonZeroDigit DecimalDigit*\\r\\nDecimalDigit = [0-9]\\r\\nNonZeroDigit = [1-9]\\r\\nExponentPart = ExponentIndicator SignedInteger\\r\\nExponentIndicator = \\\"e\\\"i\\r\\nSignedInteger = [+-]? DecimalDigit+\\r\\nBooleanLiteral = v:(TRUE / FALSE / T / F) ![a-zA-Z] {\\r\\n\\tlet value = v === 'TRUE' || v === 'T';\\r\\n\\treturn {\\r\\n    \\ttype: \\\"boolean\\\",\\r\\n        value,\\r\\n    }\\r\\n}\\r\\nReserved = (END / IS) ![a-zA-Z]\\r\\nIdentifier = !Reserved value:[a-zA-Z0-9]+ {\\r\\n\\treturn {\\r\\n    \\ttype: \\\"identifier\\\",\\r\\n        value: value.join(''),\\r\\n    }\\r\\n}\\r\\nParameterName = !Reserved first:Identifier index:(\\\"(\\\" [0-9]+ \\\")\\\")? rest:(_ ParameterName)? {\\r\\n\\tlet name = first.value;\\r\\n    if (index) {\\r\\n    \\tname += index.join('');\\r\\n    }\\r\\n\\tif (rest) {\\r\\n    \\tname += ' ' + rest[1].value;\\r\\n    }\\r\\n    return {\\r\\n    \\ttype: \\\"parameter_name\\\",\\r\\n        value: name,\\r\\n    }\\r\\n}\\r\\nParameter = index:[0-9]+ _ flag:(BooleanLiteral / _)? value:FreeCharacter* {\\r\\n\\treturn {\\r\\n    \\ttype: \\\"parameter\\\",\\r\\n    \\tindex: Number(index.join('')),\\r\\n        flag,\\r\\n        value: value.join(''),\\r\\n    }\\r\\n}\\r\\nTimerLiteral = TIMER _ \\\"#\\\" n:[0-9]+ {\\r\\n\\treturn {\\r\\n    \\ttype: \\\"timer\\\",\\r\\n        value: Number(n.join('')),\\r\\n    }\\r\\n}\\r\\n\\r\\nLl = [\\\\u0061-\\\\u007A\\\\u00B5\\\\u00DF-\\\\u00F6\\\\u00F8-\\\\u00FF\\\\u0101\\\\u0103\\\\u0105\\\\u0107\\\\u0109\\\\u010B\\\\u010D\\\\u010F\\\\u0111\\\\u0113\\\\u0115\\\\u0117\\\\u0119\\\\u011B\\\\u011D\\\\u011F\\\\u0121\\\\u0123\\\\u0125\\\\u0127\\\\u0129\\\\u012B\\\\u012D\\\\u012F\\\\u0131\\\\u0133\\\\u0135\\\\u0137-\\\\u0138\\\\u013A\\\\u013C\\\\u013E\\\\u0140\\\\u0142\\\\u0144\\\\u0146\\\\u0148-\\\\u0149\\\\u014B\\\\u014D\\\\u014F\\\\u0151\\\\u0153\\\\u0155\\\\u0157\\\\u0159\\\\u015B\\\\u015D\\\\u015F\\\\u0161\\\\u0163\\\\u0165\\\\u0167\\\\u0169\\\\u016B\\\\u016D\\\\u016F\\\\u0171\\\\u0173\\\\u0175\\\\u0177\\\\u017A\\\\u017C\\\\u017E-\\\\u0180\\\\u0183\\\\u0185\\\\u0188\\\\u018C-\\\\u018D\\\\u0192\\\\u0195\\\\u0199-\\\\u019B\\\\u019E\\\\u01A1\\\\u01A3\\\\u01A5\\\\u01A8\\\\u01AA-\\\\u01AB\\\\u01AD\\\\u01B0\\\\u01B4\\\\u01B6\\\\u01B9-\\\\u01BA\\\\u01BD-\\\\u01BF\\\\u01C6\\\\u01C9\\\\u01CC\\\\u01CE\\\\u01D0\\\\u01D2\\\\u01D4\\\\u01D6\\\\u01D8\\\\u01DA\\\\u01DC-\\\\u01DD\\\\u01DF\\\\u01E1\\\\u01E3\\\\u01E5\\\\u01E7\\\\u01E9\\\\u01EB\\\\u01ED\\\\u01EF-\\\\u01F0\\\\u01F3\\\\u01F5\\\\u01F9\\\\u01FB\\\\u01FD\\\\u01FF\\\\u0201\\\\u0203\\\\u0205\\\\u0207\\\\u0209\\\\u020B\\\\u020D\\\\u020F\\\\u0211\\\\u0213\\\\u0215\\\\u0217\\\\u0219\\\\u021B\\\\u021D\\\\u021F\\\\u0221\\\\u0223\\\\u0225\\\\u0227\\\\u0229\\\\u022B\\\\u022D\\\\u022F\\\\u0231\\\\u0233-\\\\u0239\\\\u023C\\\\u023F-\\\\u0240\\\\u0242\\\\u0247\\\\u0249\\\\u024B\\\\u024D\\\\u024F-\\\\u0293\\\\u0295-\\\\u02AF\\\\u0371\\\\u0373\\\\u0377\\\\u037B-\\\\u037D\\\\u0390\\\\u03AC-\\\\u03CE\\\\u03D0-\\\\u03D1\\\\u03D5-\\\\u03D7\\\\u03D9\\\\u03DB\\\\u03DD\\\\u03DF\\\\u03E1\\\\u03E3\\\\u03E5\\\\u03E7\\\\u03E9\\\\u03EB\\\\u03ED\\\\u03EF-\\\\u03F3\\\\u03F5\\\\u03F8\\\\u03FB-\\\\u03FC\\\\u0430-\\\\u045F\\\\u0461\\\\u0463\\\\u0465\\\\u0467\\\\u0469\\\\u046B\\\\u046D\\\\u046F\\\\u0471\\\\u0473\\\\u0475\\\\u0477\\\\u0479\\\\u047B\\\\u047D\\\\u047F\\\\u0481\\\\u048B\\\\u048D\\\\u048F\\\\u0491\\\\u0493\\\\u0495\\\\u0497\\\\u0499\\\\u049B\\\\u049D\\\\u049F\\\\u04A1\\\\u04A3\\\\u04A5\\\\u04A7\\\\u04A9\\\\u04AB\\\\u04AD\\\\u04AF\\\\u04B1\\\\u04B3\\\\u04B5\\\\u04B7\\\\u04B9\\\\u04BB\\\\u04BD\\\\u04BF\\\\u04C2\\\\u04C4\\\\u04C6\\\\u04C8\\\\u04CA\\\\u04CC\\\\u04CE-\\\\u04CF\\\\u04D1\\\\u04D3\\\\u04D5\\\\u04D7\\\\u04D9\\\\u04DB\\\\u04DD\\\\u04DF\\\\u04E1\\\\u04E3\\\\u04E5\\\\u04E7\\\\u04E9\\\\u04EB\\\\u04ED\\\\u04EF\\\\u04F1\\\\u04F3\\\\u04F5\\\\u04F7\\\\u04F9\\\\u04FB\\\\u04FD\\\\u04FF\\\\u0501\\\\u0503\\\\u0505\\\\u0507\\\\u0509\\\\u050B\\\\u050D\\\\u050F\\\\u0511\\\\u0513\\\\u0515\\\\u0517\\\\u0519\\\\u051B\\\\u051D\\\\u051F\\\\u0521\\\\u0523\\\\u0525\\\\u0527\\\\u0529\\\\u052B\\\\u052D\\\\u052F\\\\u0560-\\\\u0588\\\\u10D0-\\\\u10FA\\\\u10FD-\\\\u10FF\\\\u13F8-\\\\u13FD\\\\u1C80-\\\\u1C88\\\\u1D00-\\\\u1D2B\\\\u1D6B-\\\\u1D77\\\\u1D79-\\\\u1D9A\\\\u1E01\\\\u1E03\\\\u1E05\\\\u1E07\\\\u1E09\\\\u1E0B\\\\u1E0D\\\\u1E0F\\\\u1E11\\\\u1E13\\\\u1E15\\\\u1E17\\\\u1E19\\\\u1E1B\\\\u1E1D\\\\u1E1F\\\\u1E21\\\\u1E23\\\\u1E25\\\\u1E27\\\\u1E29\\\\u1E2B\\\\u1E2D\\\\u1E2F\\\\u1E31\\\\u1E33\\\\u1E35\\\\u1E37\\\\u1E39\\\\u1E3B\\\\u1E3D\\\\u1E3F\\\\u1E41\\\\u1E43\\\\u1E45\\\\u1E47\\\\u1E49\\\\u1E4B\\\\u1E4D\\\\u1E4F\\\\u1E51\\\\u1E53\\\\u1E55\\\\u1E57\\\\u1E59\\\\u1E5B\\\\u1E5D\\\\u1E5F\\\\u1E61\\\\u1E63\\\\u1E65\\\\u1E67\\\\u1E69\\\\u1E6B\\\\u1E6D\\\\u1E6F\\\\u1E71\\\\u1E73\\\\u1E75\\\\u1E77\\\\u1E79\\\\u1E7B\\\\u1E7D\\\\u1E7F\\\\u1E81\\\\u1E83\\\\u1E85\\\\u1E87\\\\u1E89\\\\u1E8B\\\\u1E8D\\\\u1E8F\\\\u1E91\\\\u1E93\\\\u1E95-\\\\u1E9D\\\\u1E9F\\\\u1EA1\\\\u1EA3\\\\u1EA5\\\\u1EA7\\\\u1EA9\\\\u1EAB\\\\u1EAD\\\\u1EAF\\\\u1EB1\\\\u1EB3\\\\u1EB5\\\\u1EB7\\\\u1EB9\\\\u1EBB\\\\u1EBD\\\\u1EBF\\\\u1EC1\\\\u1EC3\\\\u1EC5\\\\u1EC7\\\\u1EC9\\\\u1ECB\\\\u1ECD\\\\u1ECF\\\\u1ED1\\\\u1ED3\\\\u1ED5\\\\u1ED7\\\\u1ED9\\\\u1EDB\\\\u1EDD\\\\u1EDF\\\\u1EE1\\\\u1EE3\\\\u1EE5\\\\u1EE7\\\\u1EE9\\\\u1EEB\\\\u1EED\\\\u1EEF\\\\u1EF1\\\\u1EF3\\\\u1EF5\\\\u1EF7\\\\u1EF9\\\\u1EFB\\\\u1EFD\\\\u1EFF-\\\\u1F07\\\\u1F10-\\\\u1F15\\\\u1F20-\\\\u1F27\\\\u1F30-\\\\u1F37\\\\u1F40-\\\\u1F45\\\\u1F50-\\\\u1F57\\\\u1F60-\\\\u1F67\\\\u1F70-\\\\u1F7D\\\\u1F80-\\\\u1F87\\\\u1F90-\\\\u1F97\\\\u1FA0-\\\\u1FA7\\\\u1FB0-\\\\u1FB4\\\\u1FB6-\\\\u1FB7\\\\u1FBE\\\\u1FC2-\\\\u1FC4\\\\u1FC6-\\\\u1FC7\\\\u1FD0-\\\\u1FD3\\\\u1FD6-\\\\u1FD7\\\\u1FE0-\\\\u1FE7\\\\u1FF2-\\\\u1FF4\\\\u1FF6-\\\\u1FF7\\\\u210A\\\\u210E-\\\\u210F\\\\u2113\\\\u212F\\\\u2134\\\\u2139\\\\u213C-\\\\u213D\\\\u2146-\\\\u2149\\\\u214E\\\\u2184\\\\u2C30-\\\\u2C5E\\\\u2C61\\\\u2C65-\\\\u2C66\\\\u2C68\\\\u2C6A\\\\u2C6C\\\\u2C71\\\\u2C73-\\\\u2C74\\\\u2C76-\\\\u2C7B\\\\u2C81\\\\u2C83\\\\u2C85\\\\u2C87\\\\u2C89\\\\u2C8B\\\\u2C8D\\\\u2C8F\\\\u2C91\\\\u2C93\\\\u2C95\\\\u2C97\\\\u2C99\\\\u2C9B\\\\u2C9D\\\\u2C9F\\\\u2CA1\\\\u2CA3\\\\u2CA5\\\\u2CA7\\\\u2CA9\\\\u2CAB\\\\u2CAD\\\\u2CAF\\\\u2CB1\\\\u2CB3\\\\u2CB5\\\\u2CB7\\\\u2CB9\\\\u2CBB\\\\u2CBD\\\\u2CBF\\\\u2CC1\\\\u2CC3\\\\u2CC5\\\\u2CC7\\\\u2CC9\\\\u2CCB\\\\u2CCD\\\\u2CCF\\\\u2CD1\\\\u2CD3\\\\u2CD5\\\\u2CD7\\\\u2CD9\\\\u2CDB\\\\u2CDD\\\\u2CDF\\\\u2CE1\\\\u2CE3-\\\\u2CE4\\\\u2CEC\\\\u2CEE\\\\u2CF3\\\\u2D00-\\\\u2D25\\\\u2D27\\\\u2D2D\\\\uA641\\\\uA643\\\\uA645\\\\uA647\\\\uA649\\\\uA64B\\\\uA64D\\\\uA64F\\\\uA651\\\\uA653\\\\uA655\\\\uA657\\\\uA659\\\\uA65B\\\\uA65D\\\\uA65F\\\\uA661\\\\uA663\\\\uA665\\\\uA667\\\\uA669\\\\uA66B\\\\uA66D\\\\uA681\\\\uA683\\\\uA685\\\\uA687\\\\uA689\\\\uA68B\\\\uA68D\\\\uA68F\\\\uA691\\\\uA693\\\\uA695\\\\uA697\\\\uA699\\\\uA69B\\\\uA723\\\\uA725\\\\uA727\\\\uA729\\\\uA72B\\\\uA72D\\\\uA72F-\\\\uA731\\\\uA733\\\\uA735\\\\uA737\\\\uA739\\\\uA73B\\\\uA73D\\\\uA73F\\\\uA741\\\\uA743\\\\uA745\\\\uA747\\\\uA749\\\\uA74B\\\\uA74D\\\\uA74F\\\\uA751\\\\uA753\\\\uA755\\\\uA757\\\\uA759\\\\uA75B\\\\uA75D\\\\uA75F\\\\uA761\\\\uA763\\\\uA765\\\\uA767\\\\uA769\\\\uA76B\\\\uA76D\\\\uA76F\\\\uA771-\\\\uA778\\\\uA77A\\\\uA77C\\\\uA77F\\\\uA781\\\\uA783\\\\uA785\\\\uA787\\\\uA78C\\\\uA78E\\\\uA791\\\\uA793-\\\\uA795\\\\uA797\\\\uA799\\\\uA79B\\\\uA79D\\\\uA79F\\\\uA7A1\\\\uA7A3\\\\uA7A5\\\\uA7A7\\\\uA7A9\\\\uA7AF\\\\uA7B5\\\\uA7B7\\\\uA7B9\\\\uA7FA\\\\uAB30-\\\\uAB5A\\\\uAB60-\\\\uAB65\\\\uAB70-\\\\uABBF\\\\uFB00-\\\\uFB06\\\\uFB13-\\\\uFB17\\\\uFF41-\\\\uFF5A]\\r\\nLm = [\\\\u02B0-\\\\u02C1\\\\u02C6-\\\\u02D1\\\\u02E0-\\\\u02E4\\\\u02EC\\\\u02EE\\\\u0374\\\\u037A\\\\u0559\\\\u0640\\\\u06E5-\\\\u06E6\\\\u07F4-\\\\u07F5\\\\u07FA\\\\u081A\\\\u0824\\\\u0828\\\\u0971\\\\u0E46\\\\u0EC6\\\\u10FC\\\\u17D7\\\\u1843\\\\u1AA7\\\\u1C78-\\\\u1C7D\\\\u1D2C-\\\\u1D6A\\\\u1D78\\\\u1D9B-\\\\u1DBF\\\\u2071\\\\u207F\\\\u2090-\\\\u209C\\\\u2C7C-\\\\u2C7D\\\\u2D6F\\\\u2E2F\\\\u3005\\\\u3031-\\\\u3035\\\\u303B\\\\u309D-\\\\u309E\\\\u30FC-\\\\u30FE\\\\uA015\\\\uA4F8-\\\\uA4FD\\\\uA60C\\\\uA67F\\\\uA69C-\\\\uA69D\\\\uA717-\\\\uA71F\\\\uA770\\\\uA788\\\\uA7F8-\\\\uA7F9\\\\uA9CF\\\\uA9E6\\\\uAA70\\\\uAADD\\\\uAAF3-\\\\uAAF4\\\\uAB5C-\\\\uAB5F\\\\uFF70\\\\uFF9E-\\\\uFF9F]\\r\\nLo = [\\\\u00AA\\\\u00BA\\\\u01BB\\\\u01C0-\\\\u01C3\\\\u0294\\\\u05D0-\\\\u05EA\\\\u05EF-\\\\u05F2\\\\u0620-\\\\u063F\\\\u0641-\\\\u064A\\\\u066E-\\\\u066F\\\\u0671-\\\\u06D3\\\\u06D5\\\\u06EE-\\\\u06EF\\\\u06FA-\\\\u06FC\\\\u06FF\\\\u0710\\\\u0712-\\\\u072F\\\\u074D-\\\\u07A5\\\\u07B1\\\\u07CA-\\\\u07EA\\\\u0800-\\\\u0815\\\\u0840-\\\\u0858\\\\u0860-\\\\u086A\\\\u08A0-\\\\u08B4\\\\u08B6-\\\\u08BD\\\\u0904-\\\\u0939\\\\u093D\\\\u0950\\\\u0958-\\\\u0961\\\\u0972-\\\\u0980\\\\u0985-\\\\u098C\\\\u098F-\\\\u0990\\\\u0993-\\\\u09A8\\\\u09AA-\\\\u09B0\\\\u09B2\\\\u09B6-\\\\u09B9\\\\u09BD\\\\u09CE\\\\u09DC-\\\\u09DD\\\\u09DF-\\\\u09E1\\\\u09F0-\\\\u09F1\\\\u09FC\\\\u0A05-\\\\u0A0A\\\\u0A0F-\\\\u0A10\\\\u0A13-\\\\u0A28\\\\u0A2A-\\\\u0A30\\\\u0A32-\\\\u0A33\\\\u0A35-\\\\u0A36\\\\u0A38-\\\\u0A39\\\\u0A59-\\\\u0A5C\\\\u0A5E\\\\u0A72-\\\\u0A74\\\\u0A85-\\\\u0A8D\\\\u0A8F-\\\\u0A91\\\\u0A93-\\\\u0AA8\\\\u0AAA-\\\\u0AB0\\\\u0AB2-\\\\u0AB3\\\\u0AB5-\\\\u0AB9\\\\u0ABD\\\\u0AD0\\\\u0AE0-\\\\u0AE1\\\\u0AF9\\\\u0B05-\\\\u0B0C\\\\u0B0F-\\\\u0B10\\\\u0B13-\\\\u0B28\\\\u0B2A-\\\\u0B30\\\\u0B32-\\\\u0B33\\\\u0B35-\\\\u0B39\\\\u0B3D\\\\u0B5C-\\\\u0B5D\\\\u0B5F-\\\\u0B61\\\\u0B71\\\\u0B83\\\\u0B85-\\\\u0B8A\\\\u0B8E-\\\\u0B90\\\\u0B92-\\\\u0B95\\\\u0B99-\\\\u0B9A\\\\u0B9C\\\\u0B9E-\\\\u0B9F\\\\u0BA3-\\\\u0BA4\\\\u0BA8-\\\\u0BAA\\\\u0BAE-\\\\u0BB9\\\\u0BD0\\\\u0C05-\\\\u0C0C\\\\u0C0E-\\\\u0C10\\\\u0C12-\\\\u0C28\\\\u0C2A-\\\\u0C39\\\\u0C3D\\\\u0C58-\\\\u0C5A\\\\u0C60-\\\\u0C61\\\\u0C80\\\\u0C85-\\\\u0C8C\\\\u0C8E-\\\\u0C90\\\\u0C92-\\\\u0CA8\\\\u0CAA-\\\\u0CB3\\\\u0CB5-\\\\u0CB9\\\\u0CBD\\\\u0CDE\\\\u0CE0-\\\\u0CE1\\\\u0CF1-\\\\u0CF2\\\\u0D05-\\\\u0D0C\\\\u0D0E-\\\\u0D10\\\\u0D12-\\\\u0D3A\\\\u0D3D\\\\u0D4E\\\\u0D54-\\\\u0D56\\\\u0D5F-\\\\u0D61\\\\u0D7A-\\\\u0D7F\\\\u0D85-\\\\u0D96\\\\u0D9A-\\\\u0DB1\\\\u0DB3-\\\\u0DBB\\\\u0DBD\\\\u0DC0-\\\\u0DC6\\\\u0E01-\\\\u0E30\\\\u0E32-\\\\u0E33\\\\u0E40-\\\\u0E45\\\\u0E81-\\\\u0E82\\\\u0E84\\\\u0E87-\\\\u0E88\\\\u0E8A\\\\u0E8D\\\\u0E94-\\\\u0E97\\\\u0E99-\\\\u0E9F\\\\u0EA1-\\\\u0EA3\\\\u0EA5\\\\u0EA7\\\\u0EAA-\\\\u0EAB\\\\u0EAD-\\\\u0EB0\\\\u0EB2-\\\\u0EB3\\\\u0EBD\\\\u0EC0-\\\\u0EC4\\\\u0EDC-\\\\u0EDF\\\\u0F00\\\\u0F40-\\\\u0F47\\\\u0F49-\\\\u0F6C\\\\u0F88-\\\\u0F8C\\\\u1000-\\\\u102A\\\\u103F\\\\u1050-\\\\u1055\\\\u105A-\\\\u105D\\\\u1061\\\\u1065-\\\\u1066\\\\u106E-\\\\u1070\\\\u1075-\\\\u1081\\\\u108E\\\\u1100-\\\\u1248\\\\u124A-\\\\u124D\\\\u1250-\\\\u1256\\\\u1258\\\\u125A-\\\\u125D\\\\u1260-\\\\u1288\\\\u128A-\\\\u128D\\\\u1290-\\\\u12B0\\\\u12B2-\\\\u12B5\\\\u12B8-\\\\u12BE\\\\u12C0\\\\u12C2-\\\\u12C5\\\\u12C8-\\\\u12D6\\\\u12D8-\\\\u1310\\\\u1312-\\\\u1315\\\\u1318-\\\\u135A\\\\u1380-\\\\u138F\\\\u1401-\\\\u166C\\\\u166F-\\\\u167F\\\\u1681-\\\\u169A\\\\u16A0-\\\\u16EA\\\\u16F1-\\\\u16F8\\\\u1700-\\\\u170C\\\\u170E-\\\\u1711\\\\u1720-\\\\u1731\\\\u1740-\\\\u1751\\\\u1760-\\\\u176C\\\\u176E-\\\\u1770\\\\u1780-\\\\u17B3\\\\u17DC\\\\u1820-\\\\u1842\\\\u1844-\\\\u1878\\\\u1880-\\\\u1884\\\\u1887-\\\\u18A8\\\\u18AA\\\\u18B0-\\\\u18F5\\\\u1900-\\\\u191E\\\\u1950-\\\\u196D\\\\u1970-\\\\u1974\\\\u1980-\\\\u19AB\\\\u19B0-\\\\u19C9\\\\u1A00-\\\\u1A16\\\\u1A20-\\\\u1A54\\\\u1B05-\\\\u1B33\\\\u1B45-\\\\u1B4B\\\\u1B83-\\\\u1BA0\\\\u1BAE-\\\\u1BAF\\\\u1BBA-\\\\u1BE5\\\\u1C00-\\\\u1C23\\\\u1C4D-\\\\u1C4F\\\\u1C5A-\\\\u1C77\\\\u1CE9-\\\\u1CEC\\\\u1CEE-\\\\u1CF1\\\\u1CF5-\\\\u1CF6\\\\u2135-\\\\u2138\\\\u2D30-\\\\u2D67\\\\u2D80-\\\\u2D96\\\\u2DA0-\\\\u2DA6\\\\u2DA8-\\\\u2DAE\\\\u2DB0-\\\\u2DB6\\\\u2DB8-\\\\u2DBE\\\\u2DC0-\\\\u2DC6\\\\u2DC8-\\\\u2DCE\\\\u2DD0-\\\\u2DD6\\\\u2DD8-\\\\u2DDE\\\\u3006\\\\u303C\\\\u3041-\\\\u3096\\\\u309F\\\\u30A1-\\\\u30FA\\\\u30FF\\\\u3105-\\\\u312F\\\\u3131-\\\\u318E\\\\u31A0-\\\\u31BA\\\\u31F0-\\\\u31FF\\\\u3400-\\\\u4DB5\\\\u4E00-\\\\u9FEF\\\\uA000-\\\\uA014\\\\uA016-\\\\uA48C\\\\uA4D0-\\\\uA4F7\\\\uA500-\\\\uA60B\\\\uA610-\\\\uA61F\\\\uA62A-\\\\uA62B\\\\uA66E\\\\uA6A0-\\\\uA6E5\\\\uA78F\\\\uA7F7\\\\uA7FB-\\\\uA801\\\\uA803-\\\\uA805\\\\uA807-\\\\uA80A\\\\uA80C-\\\\uA822\\\\uA840-\\\\uA873\\\\uA882-\\\\uA8B3\\\\uA8F2-\\\\uA8F7\\\\uA8FB\\\\uA8FD-\\\\uA8FE\\\\uA90A-\\\\uA925\\\\uA930-\\\\uA946\\\\uA960-\\\\uA97C\\\\uA984-\\\\uA9B2\\\\uA9E0-\\\\uA9E4\\\\uA9E7-\\\\uA9EF\\\\uA9FA-\\\\uA9FE\\\\uAA00-\\\\uAA28\\\\uAA40-\\\\uAA42\\\\uAA44-\\\\uAA4B\\\\uAA60-\\\\uAA6F\\\\uAA71-\\\\uAA76\\\\uAA7A\\\\uAA7E-\\\\uAAAF\\\\uAAB1\\\\uAAB5-\\\\uAAB6\\\\uAAB9-\\\\uAABD\\\\uAAC0\\\\uAAC2\\\\uAADB-\\\\uAADC\\\\uAAE0-\\\\uAAEA\\\\uAAF2\\\\uAB01-\\\\uAB06\\\\uAB09-\\\\uAB0E\\\\uAB11-\\\\uAB16\\\\uAB20-\\\\uAB26\\\\uAB28-\\\\uAB2E\\\\uABC0-\\\\uABE2\\\\uAC00-\\\\uD7A3\\\\uD7B0-\\\\uD7C6\\\\uD7CB-\\\\uD7FB\\\\uF900-\\\\uFA6D\\\\uFA70-\\\\uFAD9\\\\uFB1D\\\\uFB1F-\\\\uFB28\\\\uFB2A-\\\\uFB36\\\\uFB38-\\\\uFB3C\\\\uFB3E\\\\uFB40-\\\\uFB41\\\\uFB43-\\\\uFB44\\\\uFB46-\\\\uFBB1\\\\uFBD3-\\\\uFD3D\\\\uFD50-\\\\uFD8F\\\\uFD92-\\\\uFDC7\\\\uFDF0-\\\\uFDFB\\\\uFE70-\\\\uFE74\\\\uFE76-\\\\uFEFC\\\\uFF66-\\\\uFF6F\\\\uFF71-\\\\uFF9D\\\\uFFA0-\\\\uFFBE\\\\uFFC2-\\\\uFFC7\\\\uFFCA-\\\\uFFCF\\\\uFFD2-\\\\uFFD7\\\\uFFDA-\\\\uFFDC]\\r\\nLt = [\\\\u01C5\\\\u01C8\\\\u01CB\\\\u01F2\\\\u1F88-\\\\u1F8F\\\\u1F98-\\\\u1F9F\\\\u1FA8-\\\\u1FAF\\\\u1FBC\\\\u1FCC\\\\u1FFC]\\r\\nLu = [\\\\u0041-\\\\u005A\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00DE\\\\u0100\\\\u0102\\\\u0104\\\\u0106\\\\u0108\\\\u010A\\\\u010C\\\\u010E\\\\u0110\\\\u0112\\\\u0114\\\\u0116\\\\u0118\\\\u011A\\\\u011C\\\\u011E\\\\u0120\\\\u0122\\\\u0124\\\\u0126\\\\u0128\\\\u012A\\\\u012C\\\\u012E\\\\u0130\\\\u0132\\\\u0134\\\\u0136\\\\u0139\\\\u013B\\\\u013D\\\\u013F\\\\u0141\\\\u0143\\\\u0145\\\\u0147\\\\u014A\\\\u014C\\\\u014E\\\\u0150\\\\u0152\\\\u0154\\\\u0156\\\\u0158\\\\u015A\\\\u015C\\\\u015E\\\\u0160\\\\u0162\\\\u0164\\\\u0166\\\\u0168\\\\u016A\\\\u016C\\\\u016E\\\\u0170\\\\u0172\\\\u0174\\\\u0176\\\\u0178-\\\\u0179\\\\u017B\\\\u017D\\\\u0181-\\\\u0182\\\\u0184\\\\u0186-\\\\u0187\\\\u0189-\\\\u018B\\\\u018E-\\\\u0191\\\\u0193-\\\\u0194\\\\u0196-\\\\u0198\\\\u019C-\\\\u019D\\\\u019F-\\\\u01A0\\\\u01A2\\\\u01A4\\\\u01A6-\\\\u01A7\\\\u01A9\\\\u01AC\\\\u01AE-\\\\u01AF\\\\u01B1-\\\\u01B3\\\\u01B5\\\\u01B7-\\\\u01B8\\\\u01BC\\\\u01C4\\\\u01C7\\\\u01CA\\\\u01CD\\\\u01CF\\\\u01D1\\\\u01D3\\\\u01D5\\\\u01D7\\\\u01D9\\\\u01DB\\\\u01DE\\\\u01E0\\\\u01E2\\\\u01E4\\\\u01E6\\\\u01E8\\\\u01EA\\\\u01EC\\\\u01EE\\\\u01F1\\\\u01F4\\\\u01F6-\\\\u01F8\\\\u01FA\\\\u01FC\\\\u01FE\\\\u0200\\\\u0202\\\\u0204\\\\u0206\\\\u0208\\\\u020A\\\\u020C\\\\u020E\\\\u0210\\\\u0212\\\\u0214\\\\u0216\\\\u0218\\\\u021A\\\\u021C\\\\u021E\\\\u0220\\\\u0222\\\\u0224\\\\u0226\\\\u0228\\\\u022A\\\\u022C\\\\u022E\\\\u0230\\\\u0232\\\\u023A-\\\\u023B\\\\u023D-\\\\u023E\\\\u0241\\\\u0243-\\\\u0246\\\\u0248\\\\u024A\\\\u024C\\\\u024E\\\\u0370\\\\u0372\\\\u0376\\\\u037F\\\\u0386\\\\u0388-\\\\u038A\\\\u038C\\\\u038E-\\\\u038F\\\\u0391-\\\\u03A1\\\\u03A3-\\\\u03AB\\\\u03CF\\\\u03D2-\\\\u03D4\\\\u03D8\\\\u03DA\\\\u03DC\\\\u03DE\\\\u03E0\\\\u03E2\\\\u03E4\\\\u03E6\\\\u03E8\\\\u03EA\\\\u03EC\\\\u03EE\\\\u03F4\\\\u03F7\\\\u03F9-\\\\u03FA\\\\u03FD-\\\\u042F\\\\u0460\\\\u0462\\\\u0464\\\\u0466\\\\u0468\\\\u046A\\\\u046C\\\\u046E\\\\u0470\\\\u0472\\\\u0474\\\\u0476\\\\u0478\\\\u047A\\\\u047C\\\\u047E\\\\u0480\\\\u048A\\\\u048C\\\\u048E\\\\u0490\\\\u0492\\\\u0494\\\\u0496\\\\u0498\\\\u049A\\\\u049C\\\\u049E\\\\u04A0\\\\u04A2\\\\u04A4\\\\u04A6\\\\u04A8\\\\u04AA\\\\u04AC\\\\u04AE\\\\u04B0\\\\u04B2\\\\u04B4\\\\u04B6\\\\u04B8\\\\u04BA\\\\u04BC\\\\u04BE\\\\u04C0-\\\\u04C1\\\\u04C3\\\\u04C5\\\\u04C7\\\\u04C9\\\\u04CB\\\\u04CD\\\\u04D0\\\\u04D2\\\\u04D4\\\\u04D6\\\\u04D8\\\\u04DA\\\\u04DC\\\\u04DE\\\\u04E0\\\\u04E2\\\\u04E4\\\\u04E6\\\\u04E8\\\\u04EA\\\\u04EC\\\\u04EE\\\\u04F0\\\\u04F2\\\\u04F4\\\\u04F6\\\\u04F8\\\\u04FA\\\\u04FC\\\\u04FE\\\\u0500\\\\u0502\\\\u0504\\\\u0506\\\\u0508\\\\u050A\\\\u050C\\\\u050E\\\\u0510\\\\u0512\\\\u0514\\\\u0516\\\\u0518\\\\u051A\\\\u051C\\\\u051E\\\\u0520\\\\u0522\\\\u0524\\\\u0526\\\\u0528\\\\u052A\\\\u052C\\\\u052E\\\\u0531-\\\\u0556\\\\u10A0-\\\\u10C5\\\\u10C7\\\\u10CD\\\\u13A0-\\\\u13F5\\\\u1C90-\\\\u1CBA\\\\u1CBD-\\\\u1CBF\\\\u1E00\\\\u1E02\\\\u1E04\\\\u1E06\\\\u1E08\\\\u1E0A\\\\u1E0C\\\\u1E0E\\\\u1E10\\\\u1E12\\\\u1E14\\\\u1E16\\\\u1E18\\\\u1E1A\\\\u1E1C\\\\u1E1E\\\\u1E20\\\\u1E22\\\\u1E24\\\\u1E26\\\\u1E28\\\\u1E2A\\\\u1E2C\\\\u1E2E\\\\u1E30\\\\u1E32\\\\u1E34\\\\u1E36\\\\u1E38\\\\u1E3A\\\\u1E3C\\\\u1E3E\\\\u1E40\\\\u1E42\\\\u1E44\\\\u1E46\\\\u1E48\\\\u1E4A\\\\u1E4C\\\\u1E4E\\\\u1E50\\\\u1E52\\\\u1E54\\\\u1E56\\\\u1E58\\\\u1E5A\\\\u1E5C\\\\u1E5E\\\\u1E60\\\\u1E62\\\\u1E64\\\\u1E66\\\\u1E68\\\\u1E6A\\\\u1E6C\\\\u1E6E\\\\u1E70\\\\u1E72\\\\u1E74\\\\u1E76\\\\u1E78\\\\u1E7A\\\\u1E7C\\\\u1E7E\\\\u1E80\\\\u1E82\\\\u1E84\\\\u1E86\\\\u1E88\\\\u1E8A\\\\u1E8C\\\\u1E8E\\\\u1E90\\\\u1E92\\\\u1E94\\\\u1E9E\\\\u1EA0\\\\u1EA2\\\\u1EA4\\\\u1EA6\\\\u1EA8\\\\u1EAA\\\\u1EAC\\\\u1EAE\\\\u1EB0\\\\u1EB2\\\\u1EB4\\\\u1EB6\\\\u1EB8\\\\u1EBA\\\\u1EBC\\\\u1EBE\\\\u1EC0\\\\u1EC2\\\\u1EC4\\\\u1EC6\\\\u1EC8\\\\u1ECA\\\\u1ECC\\\\u1ECE\\\\u1ED0\\\\u1ED2\\\\u1ED4\\\\u1ED6\\\\u1ED8\\\\u1EDA\\\\u1EDC\\\\u1EDE\\\\u1EE0\\\\u1EE2\\\\u1EE4\\\\u1EE6\\\\u1EE8\\\\u1EEA\\\\u1EEC\\\\u1EEE\\\\u1EF0\\\\u1EF2\\\\u1EF4\\\\u1EF6\\\\u1EF8\\\\u1EFA\\\\u1EFC\\\\u1EFE\\\\u1F08-\\\\u1F0F\\\\u1F18-\\\\u1F1D\\\\u1F28-\\\\u1F2F\\\\u1F38-\\\\u1F3F\\\\u1F48-\\\\u1F4D\\\\u1F59\\\\u1F5B\\\\u1F5D\\\\u1F5F\\\\u1F68-\\\\u1F6F\\\\u1FB8-\\\\u1FBB\\\\u1FC8-\\\\u1FCB\\\\u1FD8-\\\\u1FDB\\\\u1FE8-\\\\u1FEC\\\\u1FF8-\\\\u1FFB\\\\u2102\\\\u2107\\\\u210B-\\\\u210D\\\\u2110-\\\\u2112\\\\u2115\\\\u2119-\\\\u211D\\\\u2124\\\\u2126\\\\u2128\\\\u212A-\\\\u212D\\\\u2130-\\\\u2133\\\\u213E-\\\\u213F\\\\u2145\\\\u2183\\\\u2C00-\\\\u2C2E\\\\u2C60\\\\u2C62-\\\\u2C64\\\\u2C67\\\\u2C69\\\\u2C6B\\\\u2C6D-\\\\u2C70\\\\u2C72\\\\u2C75\\\\u2C7E-\\\\u2C80\\\\u2C82\\\\u2C84\\\\u2C86\\\\u2C88\\\\u2C8A\\\\u2C8C\\\\u2C8E\\\\u2C90\\\\u2C92\\\\u2C94\\\\u2C96\\\\u2C98\\\\u2C9A\\\\u2C9C\\\\u2C9E\\\\u2CA0\\\\u2CA2\\\\u2CA4\\\\u2CA6\\\\u2CA8\\\\u2CAA\\\\u2CAC\\\\u2CAE\\\\u2CB0\\\\u2CB2\\\\u2CB4\\\\u2CB6\\\\u2CB8\\\\u2CBA\\\\u2CBC\\\\u2CBE\\\\u2CC0\\\\u2CC2\\\\u2CC4\\\\u2CC6\\\\u2CC8\\\\u2CCA\\\\u2CCC\\\\u2CCE\\\\u2CD0\\\\u2CD2\\\\u2CD4\\\\u2CD6\\\\u2CD8\\\\u2CDA\\\\u2CDC\\\\u2CDE\\\\u2CE0\\\\u2CE2\\\\u2CEB\\\\u2CED\\\\u2CF2\\\\uA640\\\\uA642\\\\uA644\\\\uA646\\\\uA648\\\\uA64A\\\\uA64C\\\\uA64E\\\\uA650\\\\uA652\\\\uA654\\\\uA656\\\\uA658\\\\uA65A\\\\uA65C\\\\uA65E\\\\uA660\\\\uA662\\\\uA664\\\\uA666\\\\uA668\\\\uA66A\\\\uA66C\\\\uA680\\\\uA682\\\\uA684\\\\uA686\\\\uA688\\\\uA68A\\\\uA68C\\\\uA68E\\\\uA690\\\\uA692\\\\uA694\\\\uA696\\\\uA698\\\\uA69A\\\\uA722\\\\uA724\\\\uA726\\\\uA728\\\\uA72A\\\\uA72C\\\\uA72E\\\\uA732\\\\uA734\\\\uA736\\\\uA738\\\\uA73A\\\\uA73C\\\\uA73E\\\\uA740\\\\uA742\\\\uA744\\\\uA746\\\\uA748\\\\uA74A\\\\uA74C\\\\uA74E\\\\uA750\\\\uA752\\\\uA754\\\\uA756\\\\uA758\\\\uA75A\\\\uA75C\\\\uA75E\\\\uA760\\\\uA762\\\\uA764\\\\uA766\\\\uA768\\\\uA76A\\\\uA76C\\\\uA76E\\\\uA779\\\\uA77B\\\\uA77D-\\\\uA77E\\\\uA780\\\\uA782\\\\uA784\\\\uA786\\\\uA78B\\\\uA78D\\\\uA790\\\\uA792\\\\uA796\\\\uA798\\\\uA79A\\\\uA79C\\\\uA79E\\\\uA7A0\\\\uA7A2\\\\uA7A4\\\\uA7A6\\\\uA7A8\\\\uA7AA-\\\\uA7AE\\\\uA7B0-\\\\uA7B4\\\\uA7B6\\\\uA7B8\\\\uFF21-\\\\uFF3A]\\r\\nNl = [\\\\u16EE-\\\\u16F0\\\\u2160-\\\\u2182\\\\u2185-\\\\u2188\\\\u3007\\\\u3021-\\\\u3029\\\\u3038-\\\\u303A\\\\uA6E6-\\\\uA6EF]\\r\\nZs = [\\\\u0020\\\\u00A0\\\\u1680\\\\u2000-\\\\u200A\\\\u202F\\\\u205F\\\\u3000]\\r\\n\\r\\nACTION = \\\"ACTION\\\"i\\r\\nALIAS = \\\"ALIAS\\\"i\\r\\nAS = \\\"AS\\\"i\\r\\nEND = \\\"END\\\"i\\r\\nEND_TIME = \\\"END TIME\\\"i\\r\\nF = \\\"F\\\"i\\r\\nFALSE = \\\"FALSE\\\"i\\r\\nFUNCTION = \\\"FUNCTION\\\"i\\r\\nINCLUDE = \\\"INCLUDE\\\"i\\r\\nINITIATORS = \\\"INITIATOR\\\"i \\\"S\\\"i?\\r\\nIF = \\\"IF\\\"i\\r\\nIS = \\\"IS\\\"i\\r\\nLOOKUP_VARIABLE = \\\"LOOKUP VARIABLE\\\"i\\r\\nOFF = \\\"OFF\\\"i\\r\\nON = \\\"ON\\\"i\\r\\nPARAMETER_CHANGE = \\\"PARAMETER CHANGE\\\"i\\r\\nPARAMETER_FILE = \\\"PARAMETER FILE\\\"i\\r\\nPLOTFIL = \\\"PLOTFIL\\\"i\\r\\nPRINT_INTERVAL = \\\"PRINT INTERVAL\\\"i\\r\\nSENSITIVITY = \\\"SENSITIVITY\\\"i\\r\\nSET = \\\"SET\\\"i\\r\\nSI = \\\"SI\\\"i\\r\\nSTART_TIME = \\\"START TIME\\\"i\\r\\nT = \\\"T\\\"i\\r\\nTIMER = \\\"TIMER\\\"\\r\\nTITLE = \\\"TITLE\\\"i\\r\\nTRUE = \\\"TRUE\\\"i\\r\\nUSEREVT = \\\"USEREVT\\\"i\\r\\nWHEN = \\\"WHEN\\\"i\\r\\n\\r\\n__ = (WhiteSpace / LineTerminatorSequence / Comment)*\\r\\n_ = WhiteSpace*\\r\\n\\r\\n/* Expressions */\\r\\nExpressionMember = value:(Literal / Identifier) {\\r\\n\\treturn value;\\r\\n}\\r\\nArguments = value:ExpressionType rest:(_ \\\",\\\" _ Arguments)? {\\r\\n\\tlet args = [value];\\r\\n    if (rest) {\\r\\n    \\targs = args.concat(rest[3]);\\r\\n    }\\r\\n\\treturn args;\\r\\n}\\r\\nCallExpression = name:Identifier _ \\\"(\\\" args:Arguments \\\")\\\" {\\r\\n\\treturn {\\r\\n    \\ttype: \\\"call_expression\\\",\\r\\n        value: {\\r\\n        \\tname,\\r\\n            arguments: args,\\r\\n        },\\r\\n    }\\r\\n}\\r\\nExpressionOperator = \\\"**\\\" / \\\"*\\\" / \\\"/\\\" / \\\">=\\\" / \\\"<=\\\" / \\\">\\\" / \\\"<\\\" / \\\"+\\\" / \\\"-\\\"\\r\\nExpression = left:ExpressionType _ op:ExpressionOperator _ right:(Expression / ExpressionType) {\\r\\n\\treturn {\\r\\n    \\ttype: \\\"expression\\\",\\r\\n        value: {\\r\\n        \\tleft,\\r\\n            op,\\r\\n        \\tright,\\r\\n        },\\r\\n    }\\r\\n}\\r\\nExpressionBlock = \\\"(\\\" value:Expression \\\")\\\" {\\r\\n\\treturn {\\r\\n    \\ttype: \\\"expression_block\\\",\\r\\n        value,\\r\\n    }\\r\\n}\\r\\nExpressionType = CallExpression / ExpressionBlock / ExpressionMember\\r\\nAssignment = target:(CallExpression / Identifier) _ \\\"=\\\" _ value:Expr {\\r\\n\\treturn {\\r\\n    \\ttype: \\\"assignment\\\",\\r\\n        target,\\r\\n        value,\\r\\n    }\\r\\n}\\r\\nIsExpression = target:(ParameterName / CallExpression / Identifier) _ IS _ value:Expr {\\r\\n\\treturn {\\r\\n    \\ttype: \\\"is_expression\\\",\\r\\n        value: {\\r\\n        \\ttarget,\\r\\n            value,\\r\\n        },\\r\\n    }\\r\\n}\\r\\nAsExpression = target:(CallExpression / Identifier) _ AS _ value:ParameterName {\\r\\n\\treturn {\\r\\n    \\ttype: \\\"as_expression\\\",\\r\\n        value,\\r\\n    }\\r\\n}\\r\\nExpr = IsExpression / Expression / ExpressionType\\r\\nVariable = CallExpression / ExpressionMember\\r\\n\\r\\n/* Statements */\\r\\nStatement = SensitivityStatement\\r\\n\\t/ TitleStatement\\r\\n    / ParameterFileStatement\\r\\n    / IncludeStatement\\r\\n    / SI {\\r\\n    \\treturn {\\r\\n        \\ttype: \\\"units\\\",\\r\\n            value: \\\"SI\\\",\\r\\n        }\\r\\n    }\\r\\n    / ParameterChangeStatement\\r\\n    / TimeStatement\\r\\n    / PrintIntervalStatement\\r\\n    / InitiatorsStatement\\r\\n    / WhenStatement\\r\\n    / IfStatement\\r\\n    / AliasStatement\\r\\n    / PlotFilStatement\\r\\n    / UserEvtStatement\\r\\n    / FunctionStatement\\r\\n    / TimerStatement\\r\\n    / LookupStatement\\r\\nSensitivityStatement = SENSITIVITY __ value:(ON / OFF) {\\r\\n\\treturn {\\r\\n    \\ttype: \\\"sensitivity\\\",\\r\\n        value,\\r\\n    }\\r\\n}\\r\\nTitleStatement = TITLE __ value:TitleBlock? __ END {\\r\\n\\treturn {\\r\\n    \\ttype: \\\"title\\\",\\r\\n        value,\\r\\n    }\\r\\n}\\r\\nTitleBlock = first:FreeCharacter+ rest:(__ !END TitleBlock)? {\\r\\n\\tlet title = extractList(first, 1).join('');\\r\\n    if (rest) {\\r\\n    \\ttitle += '\\\\n' + rest[2];\\r\\n    }\\r\\n\\treturn title;\\r\\n}\\r\\nParameterFileStatement = PARAMETER_FILE _ v:FreeCharacter+ {\\r\\n\\treturn {\\r\\n    \\ttype: \\\"parameter_file\\\",\\r\\n        value: extractList(v, 1).join(''),\\r\\n    }\\r\\n}\\r\\nIncludeStatement = INCLUDE _ v:FreeCharacter+ {\\r\\n\\treturn {\\r\\n    \\ttype: \\\"include\\\",\\r\\n        value: extractList(v, 1).join(''),\\r\\n    }\\r\\n}\\r\\nParameterChangeStatement = PARAMETER_CHANGE __ value:StatementElements? __ END {\\r\\n\\treturn {\\r\\n    \\ttype: \\\"parameter_change\\\",\\r\\n        value: value || [],\\r\\n    }\\r\\n}\\r\\nTimeStatement = time:(START_TIME / END_TIME) _ IS _ value:NumericLiteral _? \\\".\\\"? {\\r\\n\\treturn {\\r\\n    \\ttype: \\\"time\\\",\\r\\n        time,\\r\\n        value,\\r\\n    }\\r\\n}\\r\\nPrintIntervalStatement = PRINT_INTERVAL _ IS _ value:NumericLiteral _? \\\".\\\"? {\\r\\n\\treturn {\\r\\n    \\ttype: \\\"print_interval\\\",\\r\\n        value,\\r\\n    }\\r\\n}\\r\\nInitiatorsStatement = INITIATORS __ value:StatementElements? __ END {\\r\\n\\treturn {\\r\\n    \\ttype: \\\"initiators\\\",\\r\\n        value: value || [],\\r\\n    }\\r\\n}\\r\\nWhenStatement = WHEN _ test:Expr __ value:StatementElements? __ END {\\r\\n\\treturn {\\r\\n    \\ttype: \\\"when\\\",\\r\\n        test,\\r\\n        value: value || [],\\r\\n    }\\r\\n}\\r\\nIfStatement = IF _ test:Expr __ value:StatementElements? __ END {\\r\\n\\treturn {\\r\\n    \\ttype: \\\"if\\\",\\r\\n        test,\\r\\n        value: value || [],\\r\\n    }\\r\\n}\\r\\nAliasStatement = ALIAS __ value:SourceElements? __ END {\\r\\n\\treturn {\\r\\n    \\ttype: \\\"alias\\\",\\r\\n        value,\\r\\n    }\\r\\n}\\r\\nPlotFilStatement = PLOTFIL _ n:[0-9]+ __ value:PlotFilBody? __ END {\\r\\n\\treturn {\\r\\n    \\ttype: \\\"plotfil\\\",\\r\\n        n: Number(n.join('')),\\r\\n        value,\\r\\n    }\\r\\n}\\r\\nPlotFilList = head:(CallExpression / ExpressionMember) tail:(_ \\\",\\\" _ PlotFilList)* {\\r\\n\\treturn [head].concat(extractList(tail, 3));\\r\\n}\\r\\nPlotFilBody = head:PlotFilList tail:(__ PlotFilBody)* {\\r\\n\\treturn [head].concat(extractList(tail, 1));\\r\\n}\\r\\nUserEvtStatement = USEREVT __ value:UserEvtBody? __ END {\\r\\n\\treturn {\\r\\n    \\ttype: \\\"user_evt\\\",\\r\\n        value: value || [],\\r\\n    }\\r\\n}\\r\\nUserEvtBody = head:UserEvtElement tail:(__ UserEvtElement)* {\\r\\n\\treturn [head].concat(extractList(tail, 1));\\r\\n}\\r\\nUserEvtElement = Parameter / ActionStatement / SourceElement\\r\\nActionStatement = ACTION _ \\\"#\\\" n:[0-9]+ __ value:UserEvtBody? __ END {\\r\\n\\treturn {\\r\\n    \\ttype: \\\"action\\\",\\r\\n        value: value || [],\\r\\n    }\\r\\n}\\r\\nFunctionStatement = FUNCTION _ name:Identifier _ \\\"=\\\" _ value:Expr {\\r\\n\\treturn {\\r\\n    \\ttype: \\\"function\\\",\\r\\n        name,\\r\\n        value,\\r\\n    }\\r\\n}\\r\\nTimerStatement = SET _ value:TimerLiteral {\\r\\n\\treturn {\\r\\n    \\ttype: \\\"set_timer\\\",\\r\\n        value,\\r\\n    }\\r\\n}\\r\\nLookupStatement = LOOKUP_VARIABLE _ name:Variable __ value:LookupBody? __ END {\\r\\n\\treturn {\\r\\n    \\ttype: \\\"lookup_variable\\\",\\r\\n        name,\\r\\n        value,\\r\\n    }\\r\\n}\\r\\nLookupBody = !Reserved head:FreeCharacter+ tail:(__ LookupBody)* {\\r\\n\\treturn [head].concat(extractList(tail, 1));\\r\\n}\\r\\n\\r\\n/* Program blocks */\\r\\nProgram = value:SourceElements? {\\r\\n\\treturn {\\r\\n    \\ttype: \\\"program\\\",\\r\\n        value,\\r\\n    }\\r\\n}\\r\\nSourceElements = head:SourceElement tail:(__ SourceElement)* {\\r\\n\\treturn [head].concat(extractList(tail, 1));\\r\\n}\\r\\nSourceElement = Statement / Assignment / Expr / AsExpression\\r\\nStatementElements = head:StatementElement tail:(__ StatementElement)* {\\r\\n\\treturn [head].concat(extractList(tail, 1));\\r\\n}\\r\\nStatementElement = SourceElement / ParameterName\\r\\n\";\n\n//# sourceURL=webpack://maap-input-parser/./src/maapInpParser.pegjs?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	var __webpack_export_target__ = exports;
/******/ 	for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
/******/ 	if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ 	
/******/ })()
;